<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>windows提示此WLAN使用较旧的安全标准提示的问题</title>
    <link href="/article/a0a3227b.html"/>
    <url>/article/a0a3227b.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><p>自从某一次系统更新后？还是不知道什么时候，反正以前都没这个问题，连上WIFI后，WIFI图标上有一个感叹号的标志，并且网络速率卡死在了54Mbps上，怎么都上不去。</p><p>后来登录路由器后台，发现WIFI的加密方式居然还有一个WPA，如图：</p><figure><imgsrc="../img/windows提示此WLAN使用较旧的安全标准提示的问题/image-20240916141722279.png"alt="WIFI使用了混合加密方式" /><figcaption aria-hidden="true">WIFI使用了混合加密方式</figcaption></figure><p>网上一查，说是WPA、WPA2都有很大的安全问题且协议老旧，建议使用最新的WPA3，但是看设置发现我的路由器不支持WPA3，所以只能把WPA/WPA2混合改成单独WPA2，重启路由器，发现感叹号标志消失了，无语。</p><p><strong>总结解决办法</strong>：登录路由器后台，将WIFI加密方式改成WPA2或者WPA3，抛弃WPA的加密方式。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>WLAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于信息可靠性识别的粗略应用想法</title>
    <link href="/article/7edbb404.html"/>
    <url>/article/7edbb404.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><div class="note note-warning">            <p>转载或微调文章，源地址：[在此填入源地址]</p>          </div><!-- 分类说明，发布时请删除该内容 --><table style="text-align:center;"><tr><th>一级分类</th><th>二级分类</th><th>说明</th></tr><tr><td rowspan="7">编程实践</td><td>java</td><td>java语言语法基础、高级特性、编程应用等相关文章</td></tr><tr><td>c</td><td>c语言语法基础、编程应用等相关文章</td></tr><tr><td>python</td><td>python语言语法基础、编程应用等相关文章</td></tr><tr><td>后端综合</td><td>后端综合类文章，涉及的知识例如SSM框架、SpringBoot等</td></tr><tr><td>前端综合</td><td>前端综合类文章，涉及的知识例如前端的各种脚手架、三大基础件等</td></tr><tr><td>自动化</td><td>利用各种编程语言、工具实现工作自动化的教程文章，涉及的知识例如自动打卡签到、资源爬取等</td></tr><tr><td>其他</td><td>懒得分类的文章</td></tr><tr><td rowspan="4">计算机理论</td><td>数据结构</td><td>无</td></tr><tr><td>操作系统</td><td>无</td></tr><tr><td>计算机组成原理</td><td>无</td></tr><tr><td>计算机网络</td><td>无</td></tr><tr><td rowspan="3">计算机杂项</td><td>工具的安装、配置或使用</td><td>无</td></tr><tr><td>项目文档、源码的阅读</td><td>无</td></tr><tr><td>其他</td><td>无</td></tr><tr><td rowspan="3">语文</td><td>散文</td><td>无</td></tr><tr><td>古诗</td><td>无</td></tr><tr><td>小说</td><td>无</td></tr><tr><td rowspan="3">数学</td><td>高等数学</td><td>无</td></tr><tr><td>离散数学</td><td>无</td></tr><tr><td>线性代数</td><td>无</td></tr><tr><td rowspan="3">英语</td><td>写作</td><td>无</td></tr><tr><td>听力</td><td>无</td></tr><tr><td>口语</td><td>无</td></tr><tr><td rowspan="1">音乐</td><td>唱</td><td>蔡徐坤</td></tr><tr><td rowspan="4">杂想</td><td>人物关系</td><td>无</td></tr><tr><td>社会现象</td><td>无</td></tr><tr><td>反思家附体</td><td>无</td></tr><tr><td>其他</td><td>无</td></tr></table><h1 id="前言">前言</h1><h1 id="正文">正文</h1><h2 id="正文标题1">正文标题1</h2><h3 id="正文副标题1">正文副标题1</h3><p>有次一个刚入行的妹子让我讲笑话给她听。</p><p>我：你想听 TCP 的笑话么？ 妹子：嗯，我想听一个 TCP 的笑话。我：好的，我会给你讲一个TCP 的笑话。 妹子：好的，我会听一个TCP 的笑话。我：你准备好听一个TCP 的笑话么？ 妹子：嗯，我准备好听一个TCP 的笑话我：Ok，那我要发 TCP 笑话了。大概有 10 秒，20 个字。妹子：嗯，我准备收你那个 10 秒时长，20 个字的笑话了。我：抱歉，你的连接超时了。你好，你想听 TCP 的笑话么</p><h1 id="附录">附录</h1><h3 id="附录1">附录1</h3><h3 id="附录2">附录2</h3><h1 id="参考资料">参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>作者、其他主要作者...,题名[文献类型标识](文献更新日期或者出版年):引用页码,出版地:出版者,获取和访问路径<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>待完成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字、字长、机器字长、存储字长、总线宽度等概念关系梳理</title>
    <link href="/article/ff8996e3.html"/>
    <url>/article/ff8996e3.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><p>到底是谁发明的这个概念，又到底是谁把这几个概念混着用的，我祝福你，真诚的祝福你。</p><p>本来想写一堆吐槽的话同时还想把这个问题描述清楚，但是现在突然就不想了，以下是废稿的一部分：</p><p>关于字的概念王道书上的原话是：<del>字用来表示被处理信息的单位，用来度量数据类型的长度，如X86机器中将一个字定义为16位</del><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="王道论坛,2025年计算机组成原理考研复习指导[M]:24,北京:电子工业出版社,2024-01">[1]</span></a></sup>。读完这句描述总感觉怪怪的，字是一个单位概念，那字长又是啥？单位中的单位？就感觉像是长度厘米(cm)是一个单位概念，长度的长度是啥？你给我搁这搁这呢？</p><p>再来看一个叫techtarget网站里给的定义：a word is a unit of data of adefined bit length that can be addressed and moved between storage andthe computerprocessor<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Paul Kirvan,word(in computing)[EB/OL],[https://www.techtarget.com/whatis/definition/word](https://www.techtarget.com/whatis/definition/word),2023-04">[2]</span></a></sup>，意思是字是一个定义了位长度的<strong>数据单元</strong>，可以在存储和计算机处理器之间被寻址和移动。这里把<code>unit</code>翻译成了“单元”用来表示他是一个“实体”，而不是一个“单位”，因为这句话后面说它可以被寻址和移动，所以将其翻译成“单位”显然不合适，看到这我恍然大悟，王道你的定义不会也是在哪本英文原著书上抄的吧，结果翻译错了，把“字”给我整成了一个“单位”概念，我真的无语。</p><p>综上，我认为字的概念应该如下：字是一个数据单元概念，可以用于表示每次处理的数据，并将其定义为一个单位数据，方便度量每次处理的数据。例如内存里每个数据单元存储的最多比特位数据可以把它称为一个字，CPU逻辑单元每次能处理最多比特位数据可以称为一个字，把它们都称为一个字只是为了表示它们都是一个基本的数据单元，而不是表示它们是同一个东西。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>王道论坛,2025年计算机组成原理考研复习指导[M]:24,北京:电子工业出版社,2024-01<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Paul Kirvan,word(incomputing)[EB/OL],<ahref="https://www.techtarget.com/whatis/definition/word">https://www.techtarget.com/whatis/definition/word</a>,2023-04<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机理论</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>字长</tag>
      
      <tag>各字长的关系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐讯N1刷入OpenWrt实现旁路由(保姆级教程)</title>
    <link href="/article/e0e5391f.html"/>
    <url>/article/e0e5391f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>最近感觉家里的网实在是很卡，就单纯打开个百度网页每次都会卡至少两秒钟，且卡的频率越来越频繁，最后忍无可忍，遂决定解决一下这个问题。</p><p>最初只是放弃使用光猫而使用路由器拨号上网，并且花重金购买了一个温控散热器尝试给动不动就60度的光猫散一下温，后来觉得反正都要改一下网，不如就直接弄一个软路由搁家里一次到位，主要是想装点代理插件，免得每次手机自己开代理麻烦得很。经过一系列折腾，我决定网上买个最便宜的斐讯N1盒子刷入OpenWrt来达到自己想要的效果，最终便有了这篇文章。</p><p>本篇文章主要记录本人将斐讯N1盒子刷入作者Flippy的OpenWrt系统并当成一个旁路由，最后装上代理插件实现科学上网的过程，本文章也可以作为一个简单的教程使用，为读者提供对斐讯N1盒子刷入OpenWrt并配置OpenClash代理插件的步骤参考。使用本教程实际上不需要任何前备知识，只需要按着步骤来就行。</p><h1 id="正文">正文</h1><h2 id="一目的与前置准备">一、目的与前置准备</h2><h3 id="目的">1.1 目的</h3><p>本次我的目的只是为了能有一个第三方设备可以同时为多台终端代理网络，实现科学上网，当然这个设备能够24小时运行且功耗很低那就再好不过了。</p><h3 id="前置准备">1.2 前置准备</h3><p>经过搜索查询，发现有一个叫“软路由”东西可以达成以上目的。</p><p>所谓“软路由”就是通过软件来模拟路由，实现路由器的所有功能<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="百度百科,软路由[EB/OL],[https://baike.baidu.com/item/%E8%BD%AF%E8%B7%AF%E7%94%B1/4824918](https://baike.baidu.com/item/%E8%BD%AF%E8%B7%AF%E7%94%B1/4824918)">[1]</span></a></sup>，与之相对的就是大部分人都在使用的“硬路由”，“硬路由”主要通过特定的硬件实现相应功能。所以很显然，一般在实现同等功能、成本相同的前提下硬路由因为直接借助特定硬件设备，实际上是会比软路由性能更好的，说白话就是硬路由性价比更高。</p><p>但是为啥还要使用软路由呢？六个字：可以个性定制。如果是一般硬路由，有些能实现的功能早就写死了，你真要改只能改硬件，那成本就太高了，但是软件不一样，想怎么改就怎么改，就像是安卓手机上装个抖音一样，不想看了卸载了就行，然后还可以装一个快手来看，甚至你可以同时装抖音和快手，两种短视频一起刷【直接原地升天】，可以说是非常灵活，软路由便是如此，所以实现软路由实际就是在一个设备上装一个<strong>软路由系统</strong>。</p><p>而本次我是采用一个斐讯N1盒子来刷入一个软路由系统，在此之前需要准备这些东西：</p><ul><li><strong>一个斐讯N1盒子</strong>，主设备。</li><li><strong>一台电脑</strong>，用来制作系统启动盘，同时连接N1盒子刷入一些系统引导文件，没电脑也可以直接网吧战神。</li><li><strong>一个至少2G的U盘</strong>，用于当系统启动盘。</li><li><strong>一根双公USB数据线</strong>，也就是两个头都是大口的USB线，用来连接。</li><li><strong>一根HDMI线</strong>，用来连接N1盒子，输出N1盒子的画面。</li><li><strong>一个屏幕显示设备</strong>，使用HDMI线连接N1盒子，显示N1盒子的输出画面，一般用电视机就行。</li><li><strong>一个鼠标</strong>，用来插N1盒子上操作N1盒子。</li><li><strong>一根网线</strong>，插N1盒子联网。</li></ul><p>斐讯N1盒子是2018年发布的产品，现在看来也是究极老古董了，但是我只是想刷个OpenWrt实现科学上网的功能，所以用斐讯N1那也是绰绰有余了（OpenWrt系统撑死1G出头，斐讯N1配置2G+8G，处理器4核AmlogicS905DCortex-A53，功耗2w<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="spadger,N1运行功耗测试\\[EB/OL\\]\(2019-03-15\),[https://www.right.com.cn/forum/thread-495336-1-1.html](https://www.right.com.cn/forum/thread-495336-1-1.html)">[2]</span></a></sup>，轻松带动OP，遥遥领先）。</p><p>最后汇总一下需要下载的资源的地址，读者可以先不用下载，文章后续都会给出，而且现在有可能就算你下了也不知道是用来干嘛的，在这里汇总只是方便读完后查找相应的资源：</p><ul><li><ahref="https://www.right.com.cn/forum/thread-4076037-1-1.html">Flippy-OpenWrt</a></li><li><ahref="https://github.com/balena-io/etcher/releases/download/v1.18.11/balenaEtcher-1.18.11-win.zip">balenaEtcher-1.18.11-win.zip，制作启动盘工具</a></li><li><ahref="/file/adb工具及降级固件.7z">ADB工具以及系统引导、相关降级覆盖文件压缩包</a></li></ul><h2 id="二n1刷机">二、N1刷机</h2><p>N1这个盒子很出名，主要是可以随便刷，变砖了也可以救。现在网上N1的教程也是一搜一大把，相应的适配系统直到现在2024了也是在一直更新，对小白来说那是相当友好。</p><h3 id="制作系统启动盘">2.1 制作系统启动盘</h3><p>对N1刷机之前首先得做好系统盘，把OpenWrt录入U盘里。</p><p>本文使用的Flippy改的OpenWrt系统，版本是最新发布的89版，使用Flippy的主要是他比较有名，而且到现在都还在更新，简直不要太给力，后门什么的我相信大哥不会这么搞。这是原帖地址里面也有系统下载地址：<ahref="https://www.right.com.cn/forum/thread-4076037-1-1.html">Flippy-OpenWrt</a>，里面的下载地址是百毒网盘，做好心理准备，我这里就不给其他镜像下载地址了。下载完后解压，得到这么一个解压文件：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724173413366.png"alt="img镜像文件" /><figcaption aria-hidden="true">img镜像文件</figcaption></figure><p>制作系统盘的工具这里可以使用免费开源的<code>balena-etcher</code>来制作，操作方便且免费，不过我用的时候好像出了点BUG，只能回退到<code>1.8.11</code>版本才能用，下载地址<ahref="https://github.com/balena-io/etcher/releases/tag/v1.18.11">balena-etcher-v1.18.11</a>，windows用户下载<ahref="https://github.com/balena-io/etcher/releases/download/v1.18.11/balenaEtcher-1.18.11-win.zip">balenaEtcher-1.18.11-win.zip</a>即可，下载完解压进入文件夹，此时插入准备好的U盘，点击exe直接启动：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240723233255345.png"alt="进入解压文件夹启动程序" /><figcaption aria-hidden="true">进入解压文件夹启动程序</figcaption></figure><p>启动后软件会自动识别出你的U盘（我这里用的是铠侠的U盘），只需依次选择<code>从文件烧录</code>，选择刚刚解压得到的img镜像文件，随后选择<code>现在烧录</code>即可开始烧录，等待一段时间后便完成烧录。</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240723233750336.png"alt="选择从文件烧录后选择现在烧录开始烧录" /><figcaptionaria-hidden="true">选择从文件烧录后选择现在烧录开始烧录</figcaption></figure><h3 id="n1降级">2.2 N1降级</h3><p>如果你的N1固件版本高于V2.22，那就需要先降级再刷机，要不然刷不了。</p><h4 id="打开盒子的adb">2.2.1 打开盒子的ADB</h4><p>先使用HDMI线连上显示器和N1盒子，同时将鼠标连上N1盒子，插上N1盒子的电源，开机的加载界面是个老外张开手臂的图，开机成功后的首页如图：</p><figure><img src="../img/斐讯N1刷入OpenWrt实现软路由/OIP-C.jpeg"alt="查看版本后打开ADB" /><figcaption aria-hidden="true">查看版本后打开ADB</figcaption></figure><p>可以在这里看到版本，如图显示固件版本是V2.28，使用鼠标连续点击固件版本4次，会提示“打开ADB”字样。</p><h4 id="将盒子与电脑连上同一局域网">2.2.2将盒子与电脑连上同一局域网</h4><p>在上图所示的网络信息下面，可以用鼠标点击进入WIFI设置界面把盒子连接上WIFI，之后把电脑也连接上同一个WIFI。当然你也可以通过插网线来使两个设备在同一个局域网里面。盒子连上WIFI后会显示自己的IP地址，也就是上图红框里的<code>10.10.10.120</code>。</p><h4 id="将电脑与盒子连接">2.2.3 将电脑与盒子连接</h4><p>把准备好的双公USB线一头插上盒子，另一头插上电脑，完成数据线连接。</p><p>之后下载<ahref="/file/adb工具及降级固件.7z">ADB工具以及系统引导相关文件压缩包</a>准备完成adb连接。这个压缩包文件是放到github上的，所以建议开启代理下载可以更快一点。下载完后解压到桌面，该文件夹里有如下文件：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724163704286.png"alt="压缩包文件详细" /><figcaption aria-hidden="true">压缩包文件详细</figcaption></figure><p>可以看到里面有个“安装办法”，可以先不管，进入解压文件夹后直接在地址栏输入<code>cmd</code>回车后进入<code>cmd</code>界面，如图：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724164351202.png"alt="在文件地址栏输入cmd" /><figcaption aria-hidden="true">在文件地址栏输入cmd</figcaption></figure><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724164520183.png"alt="进入cmd" /><figcaption aria-hidden="true">进入cmd</figcaption></figure><p>输入以下命令：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-45mqf9m18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-45mqf9m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb version<br></code></pre></td></tr></table></div></figure><p>如果显示如下版本信息，就OK了：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724164751157.png"alt="显示adb版本信息" /><figcaption aria-hidden="true">显示adb版本信息</figcaption></figure><p>如果失败了，包括在2.2.3与2.2.4里面的步骤出现了任何问题，就回退到这一步，按照“安装办法”里面说的将四个核心ADB文件复制到C盘的<code>system32</code>文件夹里，之后还是一模一样的操作，不过不建议这样做。到这里就把ADB连接工具准备好了，接下来就准备ADB连接。</p><p>还是在上述cmd黑框里输入以下命令，使用adb连接到盒子：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ows1bnm18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-ows1bnm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb connect 192.168.31.74<br></code></pre></td></tr></table></div></figure><p>注意把后面的ip地址替换成自己盒子的ip地址，这里的ip地址就是上面提到的<code>10.10.10.120</code>，不过我这里变了一下变成了<code>192.168.31.74</code>。连接成功后可以输入以下命令：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ybcrmem18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-ybcrmem18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb devices<br></code></pre></td></tr></table></div></figure><p>该命令可以查看adb连接的设备信息，如图：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724165949037.png"alt="adb未连接到盒子时显示空" /><figcaption aria-hidden="true">adb未连接到盒子时显示空</figcaption></figure><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724170015479.png"alt="使用adb连接到盒子" /><figcaption aria-hidden="true">使用adb连接到盒子</figcaption></figure><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724170103835.png"alt="adb成功连接到盒子后显示盒子的ip" /><figcaptionaria-hidden="true">adb成功连接到盒子后显示盒子的ip</figcaption></figure><p>完成ADB连接后进入下一步开始刷入系统引导文件，但是注意cmd窗口不要关。</p><h4 id="刷入引导文件与覆盖文件">2.2.4 刷入引导文件与覆盖文件</h4><p>首先输入以下命令进入fastboot：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-qabe22m18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-qabe22m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell reboot fastboot<br></code></pre></td></tr></table></div></figure><p>注意这个时候有可能界面会卡住，导致你不能继续接下来的输入，不过不用担心，最小化这个cmd窗口，再从当前解压后的文件夹的地址栏输入<code>cmd</code>再开一个cmd窗口，此时先检查是不是进入了fastboot，输入以下命令查看设备信息：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-djwo83m18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-djwo83m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastboot devices -l<br></code></pre></td></tr></table></div></figure><p>如果成功进入会显示如图信息：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724171302706.png"alt="成功进入fastboot" /><figcaption aria-hidden="true">成功进入fastboot</figcaption></figure><p>随后开始刷入bootloader(注意从这一步开始一定要确保你的双公USB线是连上的，而且也不要再拔了)：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ypolbym18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-ypolbym18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fastboot flash bootloader bootloader.img<br></code></pre></td></tr></table></div></figure><p>随后一次输入以下命令：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-enj3wlm18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-enj3wlm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">刷入 boot</span><br>fastboot flash boot boot.img<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷入 recovery</span><br>fastboot flash recovery recovery.img<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 fastboot</span><br>fastboot reboot<br></code></pre></td></tr></table></div></figure><p>如图所示：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724171701857.png"alt="刷入引导文件与覆盖文件" /><figcaption aria-hidden="true">刷入引导文件与覆盖文件</figcaption></figure><p>刷入成功后可以先给盒子断电，再把双公USB线和U盘什么的都可拔了，就留一个HDMI线，方便自己看运行情况，之后便可以开始准备正式刷入OpenWrt系统了。</p><h3 id="n1刷入openwrt">2.3 N1刷入OpenWrt</h3><p>将U盘插入盒子(网上都说要把U盘插入靠近HDMI口子的那一侧，我也不知道这有什么用，可能是速度更快一些？)，这个时候可以插入HDMI线方便看程序跑到哪了，最后接上盒子电源。</p><p>一接上电源就可在乌漆嘛黑的屏幕上看到一堆代码在跑，跑完后（估计几分钟）盒子会发射出WIFI信号，这时候手机或电脑连上盒子WIFI，浏览器输入默认的后台网址<code>192.168.1.1</code>可以进入盒子系统的管理界面。输入默认的账号<code>root</code>，密码<code>password</code>，登录进入系统管理界面。如图，在系统右侧打开系统-&gt;TTYD终端，登录的账号密码是通用的，也是root+password，输入账号密码登录终端(注意输入密码时默认不会显示输入的密码)：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724004541269.png"alt="登录TTYD终端" /><figcaption aria-hidden="true">登录TTYD终端</figcaption></figure><p>此时输入<code>ls</code>可以看到一个<code>install-to-emmc.sh</code>文件或者类似文件名的文件，这个就是将OpenWrt系统从U盘安装到N1盒子EMMC也就是闪存里面的执行文件，此时输入以下命令：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-7dcz7um18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-7dcz7um18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./install-to-emmc.sh<br></code></pre></td></tr></table></div></figure><p>随后出现一堆选项叫你选择版本，输入<code>11</code>选择N1盒子版本，随后会再次叫你选择需要安装的文件系统选择默认的ext4即可，也就是输入<code>1</code>。等待安装成功后显示done或者success，便可以断电再拔掉U盘。此后便可以直接再次通电，无需插入U盘即可启动OpenWrt系统。</p><h2 id="三-进入openwrt系统设置n1为旁路由">三、进入OpenWrt系统设置N1为旁路由</h2><p>到这一步刷机就已经成功，但是还需要进入OpenWrt修改一下具体配置，让盒子能连上网，同时把N1盒子当成一个旁路由使用。</p><p>在这之前需要知道自己家主路由也就是连N1盒子网线另一头的路由器的ip是多少，这个直接可以通过自己家路由器牌子的型号在网上搜，比如TP-LINK的路由器地址就是<code>192.168.1.1</code>，小米或者红米的路由器就是<code>192.168.31.1</code>，用手机或电脑连上自己的主路由，输入主路由的IP地址就可以进入路由器的后台管理界面。</p><p>知道主路由的地址后，将盒子插入网线，连接到自己家的网络，之后通上电源，等待N1盒子开机成功后，使用手机或者电脑连接盒子的WIFI，浏览器输入<code>192.168.1.1</code>进入盒子的管理界面，依次点击到<code>网络</code>-&gt;<code>接口</code>，可以看到接口总览下有一个lan口，这个口就是盒子唯一的那个网线插口，点击修改：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724180117149.png"alt="修改lan口配置" /><figcaption aria-hidden="true">修改lan口配置</figcaption></figure><p>进入修改后可以看到有一个<code>一般配置</code>与<code>DHCP服务器</code>，先修改<code>一般配置</code>:</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724180430992.png"alt="修改基本配置" /><figcaption aria-hidden="true">修改基本配置</figcaption></figure><p>如图，本文这里的主路由IP是<code>192.168.1.1</code>，为了不喝主路由地址冲突，所以将N1盒子的IPV4地址设置为<code>192.168.31.2</code>，子网掩码设置为<code>255.255.255.0</code>(注：不论你是什么牌子的路由器，只要是家用的，一般子网掩码都可以设置为255.255.255.0)，IPV4网关和DNS服务器都设置为主路由的IP，该页面的其他设置暂时不用管，不设置也没多大影响。</p><p>之后点击到<code>一般设置</code>下的<code>物理设置</code>，将桥接接口按钮取消，以及确认接口下是选中<code>lan</code>，如图：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724181128362.png"alt="配置物理配置" /><figcaption aria-hidden="true">配置物理配置</figcaption></figure><p>后面的防火墙设置也要确定选中的是lan。</p><p>随后在<code>DHCP服务器</code>设置下选择<code>忽略</code>取消DHCP功能：</p><figure><imgsrc="../img/斐讯N1刷入OpenWrt实现软路由/image-20240724181659257.png"alt="取消DHCP" /><figcaption aria-hidden="true">取消DHCP</figcaption></figure><p>完成后右下角点击<code>保存</code>，注意不要点击<code>保存&amp;应用</code>，先别急。</p><p>之后来到<code>网络</code>-&gt;<code>无线</code>设置下，把wifi关了，你也可以不用关，但是N1的WIFI很拉，8米之外直接没一点信号，开着也没用。关掉wifi会断开连接，此时使用手机或电脑连上主路由，浏览器输入刚刚设置的盒子ip，本文设置是<code>192.168.31.2</code>，输入后进入管理界面后台，设置为旁路由成功。</p><p>之后所有连接主路由的设备可以通过静态设置自己网关和DNS来让自己的流量先通过盒子旁路由，具体的方法可以看看这篇文章的最后<ahref="https://www.cnblogs.com/robotpaul/p/17127387.html#%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%97%81%E8%B7%AF%E7%94%B1%E7%9A%84%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE">需要使用旁路由的设备配置</a>，不过说实话，这样也很麻烦。</p><p>好在家里有一个闲置的老路由器，不过再加一个老路由的话，此时路由的ip设置有点差别，要同时设置wan口与lan口的ip，防止其冲突。wan口就是连接主路由那个口，wan口ip设置和盒子ip设置是一样的，只要不和主路由与盒子的ip冲突就行，本文这里设置的是<code>192.168.31.3</code>，网关和DNS都设置为盒子的ip，为<code>192.168.31.2</code>，子网掩码设置为<code>255.255.255.0</code>；lan口就是路由器自己的内网，建议把lan口和wan设置在不同网段（不过相同网段好像也没啥影响，所以可以不管不设置直接使用默认的），本文这里直接设置的是<code>192.168.1.1</code>，子网掩码为<code>255.255.255.0</code>，lan口就不需要设置网关了，因为lan口会自己经过wan口。设置好后手机连接老路由器的wifi后就可以自动走旁路由。</p><h2 id="四设置openclash">四、设置OpenClash</h2><p>本文使用的机场订阅进行科学上网，所以使用的是OpenClash插件，因为太简单了，就不贴图了。</p><p>在服务下找到OpenClash插件，到<code>运行状态</code>界面此时会跳出几个下载链接选项（我用的时候那个界面白茫茫的一片，还得仔细看才看得出来），叫下载安装内核，它会自己测试各连接的连通性，一般选择第一个就行，然后就是不要动那个界面一直等下载安装完成，完成后可以到<code>插件设置</code>-&gt;<code>版本更新</code>那里看有没有当前版本提示，如果没有，可以再次手动点击<code>检查并更新</code>，3个内核与一个客户端都可以下载，但是至少下载一个内核。</p><p>然后在<code>配置订阅</code>中输入自己的订阅地址，启动后便大功告成。</p><h1 id="参考资料">参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度百科,软路由[EB/OL],<ahref="https://baike.baidu.com/item/%E8%BD%AF%E8%B7%AF%E7%94%B1/4824918">https://baike.baidu.com/item/%E8%BD%AF%E8%B7%AF%E7%94%B1/4824918</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>spadger,N1运行功耗测试[EB/OL](2019-03-15),<ahref="https://www.right.com.cn/forum/thread-495336-1-1.html">https://www.right.com.cn/forum/thread-495336-1-1.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://www.cnblogs.com/robotpaul">巴塞罗那的余晖</a>,【OpenWrt】N1刷机过程及旁路由设置（通用）[EB/OL](2023-02-16),<ahref="https://www.cnblogs.com/robotpaul/p/17127387.html">https://www.cnblogs.com/robotpaul/p/17127387.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>抖腿电子狗,【小白必看】斐讯N1盒子降级、刷机教程[EB/OL](2020-01-14),<ahref="https://www.znds.com/forum.php?mod=viewthread&amp;tid=1163227">https://www.znds.com/forum.php?mod=viewthread&amp;tid=1163227</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>软路由</tag>
      
      <tag>刷机</tag>
      
      <tag>斐讯N1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么大部分人都应主动学习计算机专业知识</title>
    <link href="/article/3dde4174.html"/>
    <url>/article/3dde4174.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><p>刚刚在哔站上看到了一个视频，是UP主温峻岩的<ahref="https://www.bilibili.com/video/BV1H7421T77z/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=61a94b0c353810f2672fb8cfda78ef1b">《网络和短视频是如何毁灭儿童的？——50分钟读懂<童年的消逝>》</a>，这个视频虽然主要目的是想讲网络和短视频的危害，但是在该视频的第三部分有说到当今学校的一个重要作用就是：筛选与隔离，筛选就是知识的筛选，隔离就是环境的隔离，两者结合可以让学生在隔离的环境中安心学习经过筛选的知识，从而高效地吸收并理解属于人类社会中的一部分“精华”知识，快速地构建起一套完整有用的知识体系。我觉得这个说法很有道理，因为结合我自己的感受也确实是如此。不过由此我突然对于为什么应当要学习计算机基础知识、甚至专业知识有了更深一点的见解，因为我一直都认为计算机基础知识应当是每个现代人必须需要掌握的技能之一，原因自不必多说，但是随着计算机互联网的迅猛发展，现在一些较“专业”的计算机知识的学习门槛也几乎降到了零，所以我也认为这些知识也是每一个现代人需要自觉掌握的，而接下来我会谈谈我对其中的原因理解。</p><p>实际上现在的人类社会信息的主要生产地毫无疑问是互联网，引用一段较老的分析报告：“IDC预计，到 2025 年，属于数据分析的全球数据总量将增长至原来的 50 倍， 达到5.2ZB；而认知系统“触及”的分析数据总量将增长至原来的 100 倍，达到1.4ZB！”，这仅仅是2017年初的预测，而5.2ZB是什么概念，</p><p>知识搜集与整理</p><p>1.什么是“计算机思维”？</p><p>人为创造的逻辑，人为创造的规则约束。强逻辑性，重实用性，复用思维，站在巨人的肩膀上，架构思维，对新事物的高度包容性，计算力就是生产力。</p><p>2.计算机思维有什么用？</p><p>学习指导，生活指导，行事指导。</p><p>3.计算机专业知识有什么用？</p><p>互联网分享精神，知识的寻探，知识门槛的降低。生活中各事物的认识与使用（已经离不开），生产力：创造力的发挥，低成本的价值实现。</p><p>4.重过程不重结果</p><p>学习计算机思维，不能以目标结果为导向，应该在过程中</p><p>5.保持思维敏锐性</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>待完成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中的多线程通信方式</title>
    <link href="/article/c6bac89b.html"/>
    <url>/article/c6bac89b.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><div class="note note-warning">            <p>转载或微调文章，源地址：[在此填入源地址]</p>          </div><h1 id="前言">前言</h1><p>多线程在java的学习路上是必经之路，java的一大特点也是支持多线程(感觉现在主流的语言基本上都支持多线程了)，这样就不用用户自己去调用操作系统的多线程功能来实现多线程程序。不过因为自己平时碰到需求很弱鸡，很少用到java的多线程，最近闲来没事想优化一下之前写的一个安卓的APP，结果就直接卡在了第一步的需求实现：在APP处于加载欢迎页面的过程中，同时检测APP是否有更新，如果有更新就在用户进入主页后弹出对话框等待用户确认是否更新，如果没有更新就啥也不干。由于直接代码写太乱了，各种线程乱成一麻绞在一起，我理了半天也没理清怎么把这个检测更新的线程加上去，然后想着重写算了，但是一时竟无从下键盘——为啥？因为我连java有几种实现多线程的方式都忘了。</p><p>今天主要就是帮助自己再理清一次java的多线程使用，以前没啥写笔记的习惯，学了就忘了，今天准备写点笔记记下来。本文章主要会从线程的概念入手，随后介绍java多线程的实现方式与实战案例，最后再到java多线程的通信方式，顺便实现上面说的那个检测更新的需求。</p><h1 id="正文">正文</h1><h2 id="进程与线程">1.进程与线程</h2><p>在了解“进程”与“线程”之前，需要注意不管是“进程”还是“线程”，它们都是一个中文词语罢了，对于一些初学者来说很容易陷入到对这些词语本身的理解之中，但是要明白这些词语不过就是一个用来描述一种具体或者抽象的东西的符号，它们只是一个符号，仅此而已。就像是“大树”这个词语，不要去试图理解“大树”这个符号是什么东西，而是要理解平时使用“大树”这个符号时，我们实际是想要描述一个什么样的东西：例如一颗很粗壮的树。对于“进程”或者“线程”，实际上这个两个词语对于不了解的初学者来说是比较抽象的，一听到这两个词语就不知道这是啥意思，所以不要试图去理解这些符号本身是什么东西，要去理解这些符号本身想要表达的东西，这样以后一看到“进程”就像一看到“树”这个字一样，脑海里自然而然就出现了它背后所代表的东西。</p><h2 id="什么是进程">1.1 什么是进程</h2><p>虽然进程是计算机里面专属的词语，它用来描述一个运行的程序，但是实际上"进程"背后所代表的思想是符合现实中许多需要处理的事务特点的，所以接下来就从现实例子出发的同时与计算机结合来介绍这个概念。</p><p>假设有这么一个场景：目前你手中有一根吸管，面前有三杯奶茶，一杯是酸的，一杯是甜的，还有一杯是辣的（别问我为什么会有辣的奶茶存在🤺），假设这个时候你只能用那一根吸管最多同时喝一杯奶茶。</p><p>CPU对应吸管，一颗CPU同时只能处理一个事务，一根吸管同时只能吸一种奶茶</p><p>进程对应一整个想要喝的这件事</p><p>线程对应喝什么奶茶这件事</p><h2 id="什么是线程">1.2 什么是线程</h2><h2 id="进程与线程的关系与意义">1.3 进程与线程的关系与意义</h2><h2 id="现代操作系统中的进程与线程">1.4 现代操作系统中的进程与线程</h2><h2 id="java的多线程">2.java的多线程</h2><p>多种实现方式与各个方式的区别</p><h3 id="thread">2.1 thread</h3><h3 id="section">...</h3><h2 id="java的多线程通信">3.java的多线程通信</h2><h3 id="section-1">...</h3><h1 id="附录">附录</h1><h3 id="附录1">附录1</h3><h3 id="附录2">附录2</h3><h1 id="参考文献">参考文献</h1>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>java</tag>
      
      <tag>java多线程</tag>
      
      <tag>待完成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程连接mysql遇到的问题</title>
    <link href="/article/d43c8739.html"/>
    <url>/article/d43c8739.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>今天心血来潮，想着自己那没前途的工作就感到十分绝望，可是看如今java大势已去，加上自己0经验，早就是属于凉透了那一批“计算机科班”，不过自己还是想挣扎一下，又捡起这该死的java，且狠狠地花了199￥买了个云服务器，准备完善之前学的API项目。</p><p>显然，这边文章能出来，就是说明我遇到了问题。我本来想远程连接服务器那边的mysql，但是死活连不上，然后呢就是排查问题，也花了我好几个小时才搞定，这能忍？必须把这个问题给记录下来！</p><p>本文主要涉及我在远程连接mysql上遇到的两个问题以及对应的解决办法。</p><h1 id="正文">正文</h1><h2 id="连接超时">1.连接超时</h2><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-9m493mm18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-9m493mm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Failed<br>DBMS: MySQL (ver. <span class="hljs-number">8.0</span><span class="hljs-number">.36</span>-0ubuntu0<span class="hljs-number">.22</span><span class="hljs-number">.04</span><span class="hljs-number">.1</span>)  Case sensitivity: plain=exact, delimited=exact Driver: MySQL Connector/J (ver. mysql-connector-j-<span class="hljs-number">8.2</span><span class="hljs-number">.0</span> (Revision: 06a1f724497fd81c6a659131fda822c9e5085b6c), JDBC4<span class="hljs-number">.2</span>)<br><br>Connection timed out: connect.<br></code></pre></td></tr></table></div></figure><p>遇到这个，可能是网络被挡了：</p><p>①检查自己网络是否通畅</p><p>②检查自己远程连接的ip或者域名是否正确</p><p>③以上均无误，则最大可能是自己服务器的防火墙开了，把端口给挡了，需要打开端口访问</p><h2 id="连接被拒绝">2.连接被拒绝</h2><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-t1ga13m18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-t1ga13m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Failed<br>DBMS: MySQL (ver. <span class="hljs-number">8.0</span><span class="hljs-number">.36</span>-0ubuntu0<span class="hljs-number">.22</span><span class="hljs-number">.04</span><span class="hljs-number">.1</span>)  Case sensitivity: plain=exact, delimited=exact Driver: MySQL Connector/J (ver. mysql-connector-j-<span class="hljs-number">8.2</span><span class="hljs-number">.0</span> (Revision: 06a1f724497fd81c6a659131fda822c9e5085b6c), JDBC4<span class="hljs-number">.2</span>)<br><br>Connection refused: connect. <br></code></pre></td></tr></table></div></figure><p>这种就是远程的mysql数据库拒绝了你的连接请求，那就可能是：</p><p>①服务器mysql没有授予其他ip访问的权限，此时登录服务器数据库，手动授予：</p><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-us5fh7m18zzwd7"></i><span>MYSQL</span><div class="collapse show" id="collapse-us5fh7m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 先看看啥情况<br>select host, user from user; <br></code></pre></td></tr></table></div></figure><p>如过对应的用户的host里面没有包括自己的ip（一般默认是locahost，那肯定不行）那需要改一下，一般改成<code>%</code>，意为允许所有ip访问【改之后记得重启mysql】：</p><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-kk9ps0m18zzwd7"></i><span>MYSQL</span><div class="collapse show" id="collapse-kk9ps0m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 授予访问权限<br>update user set host=&#x27;%&#x27; where user=&#x27;对应的用户名&#x27;<br></code></pre></td></tr></table></div></figure><p>②如果是linux服务器，那还要设置一个配置文件：</p><p>一般Mysql默认安装的话那个文件的路径为<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>，然后进<code>mysqld.cnf</code>把<code>bind-address=127.0.0.1</code>注释掉，或者改成<code>0.0.0.0</code>就OK，注意得用root权限才改得了，然后重启mysql就OK。</p><div class="note note-warning">            <p>记得改完配置后需要重启mysql服务器，或者你有其他方法使mysql自己更新配置也行</p>          </div>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>工具的安装、配置或使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>mysql</tag>
      
      <tag>mysql远程连接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/article/b30ceb9f.html"/>
    <url>/article/b30ceb9f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="linux分类">1. Linux分类</h1><p>大概有：RedHat和DeBian两大类以及其他类。RedHat下的CentOS稳定，更新少，yum安装管理，安装软件包为<code>.rpm</code>；DeBian下的Ubuntu更新快，apt安装管理，图形界面友好，新手友好，安装软件包为<code>.deb</code>。</p><p>注：Shell是用户与操作系统内核的接口(命令行接口，除此之外还有编程接口API)，Linux一般默认使用BashShell。</p><h1 id="目录结构规范">2. 目录结构规范</h1><p><strong>①系统启动必须：</strong></p><ul><li><strong>/boot：</strong>存放的启动Linux时使用的内核文件，包括连接文件以及镜像文件。</li><li><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</li><li><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</li></ul><p><strong>②指令集合：</strong></p><ul><li><strong>/bin：</strong>存放着最常用的程序和指令</li><li><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</li></ul><p><strong>③外部文件管理：</strong></p><ul><li><strong>/dev ：</strong>Device(设备)的缩写,存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</li><li><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</li><li><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li></ul><p><strong>④临时文件：</strong></p><ul><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有/var/run 目录，应该让它指向 run。</li><li><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li></ul><p><strong>⑤账户：</strong></p><ul><li><strong>/root</strong>：系统管理员的用户主目录。</li><li><strong>/home</strong>：用户的主目录，以用户的账号命名的。</li><li><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的programfiles目录。</li><li><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</li><li><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong>内核源代码默认的放置目录。</li></ul><p><strong>⑥运行过程中要用：</strong></p><ul><li><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log目录下）。</li><li><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</li></ul><p><strong>⑦扩展用的：</strong></p><ul><li><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</li><li><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></li></ul><h1 id="常用文件管理命令">3. 常用文件管理命令</h1><ul><li>通配符<ul><li><code>*</code>：0个或任意字符</li><li><code>?</code>：一个字符</li><li><code>[]</code>：匹配一组单个字符，示例<code>[0-9]</code>、<code>[a-z]</code>，似乎只能这么勇</li></ul></li><li><code>ls</code>，查看文件信息<ul><li><code>ls -R</code>：递归列出子文夹</li><li><code>ls -m</code>：逗号分隔显示的内容列表</li><li><code>ls -a</code>：显示所有的文件内容，包括隐藏文件</li><li><code>ls -F</code>：显示文件类型</li><li><code>ls -l</code>：显示文件的权限、所有者等等详细信息</li></ul></li><li><code>pwd</code>：print workingdirectory，显示当前工作目录的完整路径</li><li><code>cd -</code>：返回以前的目录</li><li><code>mkdir [*filename]</code>：创建一个空文件夹，默认是所有者读、写、以及执行的权限，而其他任何人则只有读、执行的权限</li><li><code>cp [*a_file_uri] [*b_file_uri]</code>：复制文件到指定位置，并指定名称<ul><li><code>cp -i</code>：复制文件时遇到重复文件给予确认警告</li><li><code>cp -R</code>：（递归）复制目录</li><li><code>cp -a</code>：完全复制(archivemode)，会复制文件的所有属性，同时不会复制软链接里真的得文件内容，加快复制速度</li></ul></li><li><code>mv [*a_file_uri] [*b_file_uri]</code>：移动文件到另一个指定位置，并使用特定文件名</li><li><code>rm</code>：删除文件，可以使用空格隔开多个或者直接使用通配符，若删除带有空格的文件，可使用双引号括住<ul><li><code>rm -i</code>：在每次删除文件时都给与警告提示</li><li><code>rm -Rf</code>：R为递归操作，f为force强制的意思，即强制递归删除一个文件，可用于删除文件夹</li></ul></li><li><code>su -l [username]</code>：切换用户，包括环境变量。注意默认是切换到root用户</li><li><code>man -f [*command_name]</code>：显示一个命令的使用描述</li><li><code>cat</code>：链接多个文件的内容并输出到终端【还有个tac，作用是反向拼接，把猫倒过来了】，这是一次性输出完到最后一行，没有分页功能<ul><li><code>cat -n</code>：给输出加上行号</li></ul></li><li><code>less</code>：进入less模式分页查看文本文件，类似<code>vim</code>编辑器，可以使用<code>/</code>搜索文本，支持正则表达式</li><li><code>head</code>与<code>tail</code>：查看文件前n行或后n行内容，默认10行<ul><li><code>head -n [*一个数字x]</code>：查看前x行</li><li><code>tail -n [*一个数字x] -f</code>：查看后x行，且不断更新内容，f即follow</li></ul></li><li><code>chgrp [*用户组的名称或者数字] 文件</code>：修改文件所属用户组，加个<code>-R</code>就是递归修改目录</li><li><code>chmod [ugo][+-=][rwx]</code>：修改各个控制列表的权限。==（注意：linux中有三个控制列表，分别是user、group、others。）==，<code>+</code>、<code>-</code>、<code>=</code>分别表示增加权限，减少权限和直接修改权限为指定权限。示例：<code>chmod go=r</code>，修改组和其他用户的权限为可读。</li><li><code>chmod [0-7] [0-7] [0-7]</code>：以八进制形式实现修改各个控制列表的权限的功能。三个数字分别代表三个组的rwx权限情况。示例：<code>chmod 744</code>，修改组和其他用户的权限为可读，但是如果不想动user的权限怎么办？chatgpt说先看然后再改成一样的</li><li><code>zip</code>与<code>gzip</code>：压缩文件<ul><li><code>unzip</code>与<code>gunzip</code>：解压文件</li></ul></li><li><code>locate [*文件关键字]</code>：从文件名数据库中搜索相关文件，嘎嘎快，但是搜不到新建的文件，必须得刷新</li><li><code>grep [*正则表达式] [*文件名]</code>：从文本文件中搜索关键字并输出</li><li><code>find [*文件路径] -name [关键字]</code>：根据关键字来搜索文件或文件夹，即时搜索（默认递归搜索），不依赖文件名数据库</li><li><code>dpkg</code>：Debian的包管理工具<ul><li><code>dpkg -i</code>：安装</li><li><code>dpkg -r</code>：卸载</li></ul></li><li><code>apt</code>：牛逼的包管理工具<ul><li><code>apt update</code>：更新安装包数据库，需要root</li><li><code>apt upgrade</code>：更新所有软件，需要root</li><li><code>apt install [*package_name]</code>：安装指定包，需要root</li></ul></li></ul><h2 id="总结">3.1 总结</h2><p>增：<code>mkdir</code>、<code>vim</code>、<code>cp</code>、<code>zip与gzip</code></p><p>删：<code>rm</code>、<code>mv</code></p><p>改：<code>chgrp</code>、<code>chmod</code>、<code>cp</code></p><p>查：<code>locate</code>、<code>grep</code>、<code>find</code></p><p>看：<code>cat</code>、<code>head</code>、<code>tail</code></p><h1 id="常用系统资源管理命令">4. 常用系统资源管理命令</h1><ul><li><code>ps</code>：显示进程信息<ul><li><code>ps aux</code>：显示所有用户(a)的进程信息</li><li><code>ps U [*username]</code>：显示指定用户的进程信息</li></ul></li><li><code>ss -a</code>：查看所有状态链接的套接字状态(套接字就是端口后面的东西)</li></ul><h1 id="常用网络管理命令">5. 常用网络管理命令</h1><ul><li><code>ifconfig</code>：查看网络接口配置</li><li><code>route</code>：查看路由表</li><li><code>ssh [*username]@[*ip_address]</code>：远程连接到另一台计算机。ssh：secureshell</li><li><code>sftp [*username]@[*ip_address]</code>：连接到另一台计算机，并与本地计算机相互传输文件</li></ul><h1 id="命令进阶">6. 命令进阶</h1><ul><li>组合命令<ul><li><code>;</code>：命令栈方式，用分号隔开命令，依顺序运行，不论前一个命令是否执行成功</li><li><code>&amp;&amp;</code>、<code>||</code>：逻辑判断链方式，<code>&amp;&amp;</code>表示前一个命令执行成功后一个才能执行，<code>||</code>表示前一个命令执行失败后一个才能执行</li></ul></li><li><code>stdin</code>、<code>stdout</code>、<code>stderr</code>，三种标准输入输出<ul><li><code>|</code>：把前一个命令的<code>stdout</code>从默认终端重定向至下一个命令的<code>stdin</code>，这是一个管道控制命令。注意：vim不能使用这个命令，因为vim会接管整个shell。示例：<code>ps -Al | grep vim</code></li><li><code>&gt;</code>：把前一个命令的<code>stdout</code>从默认终端重定向输出到指定文件的<code>stdin</code>，如果文件不存在则创建，如果已经存在则会覆盖原有文件内容。示例：<code>ls -l &gt; niubi.txt</code></li><li><code>&gt;&gt;</code>：把前一个命令的<code>stdout</code>从默认终端输出重定向到指定文件的<code>stdin</code>，如果文件不存在则创建文件，若存在则以追加的形式输出到文件中</li><li><code>&lt;</code>：把一个文件的<code>stdout</code>重定向到前一个命令的<code>stdin</code>中。示例：<code>echo &lt; niubi.txt</code>，终端会打印niubi.txt的内容</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>Linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Linux基础</tag>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中列级约束与表级约束的区别以及两者存在的意义</title>
    <link href="/article/609338f3.html"/>
    <url>/article/609338f3.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>一直都是对MySQL处于懵懵懂懂的状态，刚刚突然去了解了一下MySQL的约束相关问题，发现MySQL中常用的有六种约束（注：我在8.4版本的<ahref="https://dev.mysql.com/doc/refman/8.4/en/constraint-enum.html">手册</a>中还找到了几个约束如：<code>SET</code>、<code>ENUM</code>，但是到底有多少种约束，不知道），分别是：<code>PRIMARY KEY</code>、<code>FOREIGN KEY</code>、<code>UNIQUE</code>、<code>NOT NULL</code>、<code>DEFAULT</code>、<code>CHECK</code>。然后细分又可以分为列级约束和表级约束两大类<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="codeacg,MySQL表级约束和列级约束\\[EB/OL\\]\(2021-04-28),[https://blog.csdn.net/qq_48759664/article/details/116240961](https://blog.csdn.net/qq_48759664/article/details/116240961)">[1]</span></a></sup>：</p><table><thead><tr class="header"><th>约束</th><th>关键字</th></tr></thead><tbody><tr class="odd"><td>列级约束</td><td><code>PRIMARY KEY</code>、<code>FOREIGN KEY</code>、<code>UNIQUE</code>、<code>NOT NULL</code>、<code>DEFAULT</code>、<code>CHECK</code></td></tr><tr class="even"><td>表级约束</td><td><code>PRIMARY KEY</code>、<code>FOREIGN KEY</code>、<code>UNIQUE</code>、<code>CHECK</code></td></tr></tbody></table><p>可以看到，表级约束有的，列级约束都有。于是我去搜了一圈关于两种约束有什么区别的文章，最后都是在定义和最终作用上说的，而且在最终作用上只是说列级约束是约束当前列，而表级约束是同时约束多个列，但是我想如果在每个列级约束上加上同一种约束不就可以起到表级约束相同的效果了吗？而且为什么表级约束不能有<code>DEFAULT</code>和<code>NOT NULL</code>？列级约束和表级约束到底约束了个什么？</p><p>带着以上疑问，此篇文章诞生。此篇文章也主要解决以上两个问题。</p><h1 id="正文">正文</h1><h2 id="一.什么是约束">一.什么是约束</h2><p>“约束”就是使用约定对XX进行束缚，这个“束缚”有很多作用，例如小明老婆生了个儿子，法律规定从此以后他就是这个儿子的爸，这对小明进行了一个身份约束，以后小明儿子学校里打架了，顺着这个身份约束去找小明就对了，然后小明把他儿子框框打一顿，他儿子以后就再也不敢打架了，这便解决了一个问题。</p><p>SQL里约束的洋文叫做<code>contraint</code>，SQL约束用于规定表中的数据规则，如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过CREATETABLE语句)，也可以在创建表之后规定(通过ALTERTABLE语句)<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="菜鸟教程,SQL约束(Constraints)\\[EB/OL\\],[https://www.runoob.com/sql/sql-constraints.html](https://www.runoob.com/sql/sql-constraints.html)">[2]</span></a></sup>。一句话，SQL中的约束决定了表或列中的数据是否有效。</p><h2 id="二.mysql中的约束">二.MySQL中的约束</h2><h3 id="常用约束">2.1 常用约束</h3><p>MySQL主要常用的约束有六种，分别是：</p><p>①<code>PARIMARY KEY</code>：主键约束。约束某一列或者多列数据值不重复且不为空，注意这里的空指的是<code>NULL</code>，不是指空串，以下文中提到的空都是这个意思。</p><p>②<code>FROEIGN KEY</code>：外键约束。针对不同表的列来创建父子列关系约束，约束子列的值取值范围只能在父列已有值的范围下。</p><p>③<code>UNIQUE</code>：唯一约束。约束某一列或多列数据值唯一，但是可以有多个空。</p><p>④<code>NOT NULL</code>：非空约束，对应<code>NULL</code>空约束。对某一列数据是否能为空做约束。</p><p>⑤<code>DEFAULT</code>：默认值约束。对某一列数据做默认值约束，当没有对其赋值时，则使用默认值。</p><p>⑥<code>CHECK</code>：值检查约束，MySQL8.0.16+才支持，之前的版本写了<code>CHECK</code>约束不会报错，同样也不会生效，MySQL只会忽略这个约束<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Praveenkumar Hulakund](https://dev.mysql.com/blog-archive/?author=Praveenkumar Hulakund),MySQL 8.0.16 Introducing CHECK constraint\\[EB/OL\\]\(2019-04-26),[https://dev.mysql.com/blog-archive/mysql-8-0-16-introducing-check-constraint/](https://dev.mysql.com/blog-archive/mysql-8-0-16-introducing-check-constraint/)">[3]</span></a></sup>。</p><p>接下来对这六个约束进行创建演示(为了方便随便建的表，其他的误考虑)，假设某一个班有多个学生，每个学生都已经满18岁，每个学生也都有唯一对应的十位学号，这个班部分学生这学期选修了一门课程（每一门课程也对应一个唯一ID），其余学生则是一门都没有选修，现设计两张表来存储这些学生的信息：</p><p>首先是选修课程表<code>elective_course</code>：</p><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-whfbtlm1naw7jw"></i><span>MYSQL</span><div class="collapse show" id="collapse-whfbtlm1naw7jw"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS elective_course(<br>    #主键约束，课程ID不能重复且不能为空<br>id INT PRIMARY KEY,<br>    #NOT NULL非空约束，课程名不能为空，CHECK值检查约束，name不能为空串<br>    name VARCHAR(32) NOT NULL CHECK(name!=&#x27;&#x27;)<br>);<br></code></pre></td></tr></table></div></figure><p>然后是学生表<code>student</code>，包括了学生信息与选课信息：</p><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-daf1nsm1naw7jw"></i><span>MYSQL</span><div class="collapse show" id="collapse-daf1nsm1naw7jw"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS student(<br>#主键约束，学生ID不能重复且不能为空<br>    id INT(10) PRIMARY KEY,<br>    #非空约束，学生名不能为空，检查约束，学生名不能为空串，唯一约束，学生名不能重复但可以为空<br>    #注意，以上这种多种约束，是取约束的合集，也就是取最严的那个约束作为最终约束结果【我猜的】<br>    name VARCHAR(32) NOT NULL CHECK(name!=&#x27;&#x27;) UNIQUE,<br>    #检查约束，年龄必须大于等于18<br>    age INT CHECK(age&gt;=18),<br>    #非空约束，课程ID不能为空<br>    course_id INT NOT NULL,<br>    #外键约束，课程表中的`id`是指向学生表`course_id`的外键<br>    FOREIGN KEY(course_id) REFERENCES elective_course(id)<br>);<br></code></pre></td></tr></table></div></figure><h3 id="列级约束与表级约束">2.2 列级约束与表级约束</h3><p>列级约束：如其名，就是针对某一列的约束；表级约束：如其名，就是针对全表的约束，但是注意这个意思并不是对全表所有的列都有约束，只是设置表约束的时候有个特点，即都是在定义表之后单独设置的表级约束，而列约束一般都是在定义列之后直接可以设置。如下：</p><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ogepc2m1naw7jw"></i><span>MYSQL</span><div class="collapse show" id="collapse-ogepc2m1naw7jw"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#列级约束<br>CREATE TABLE person (<br>    . . .<br>    age INT CHECK (age &gt;= 0),<br>    . . .<br>);<br></code></pre></td></tr></table></div></figure><figure class="highlight plaintext"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ftz0g4m1naw7jw"></i><span>MYSQL</span><div class="collapse show" id="collapse-ftz0g4m1naw7jw"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#表级约束<br>CREATE TABLE qualified_borrowers (<br>    . . .<br>    account_number INT,<br>    acceptable_collateral BOOLEAN,<br>    . . .<br>    CHECK (account_number IS NOT NULL AND acceptable_collateral = true)<br>);<br></code></pre></td></tr></table></div></figure><p>所以怎么区分列级约束和表级约束呢？当然不是看约束是在哪定义的，而是结合定义，看约束了多少个列，只约束了一个列那就是列级约束，约束了两个或两个以上就是表级约束。</p><p>所以最后的问题，两者的区别是啥以及在使用这两者的时候需要注意什么？但是我搜了一圈，也没看见几个讨论这两者的区别以及注意事项的。要说区别的话，就是字面意思上的区别，一个只约束一列，一个（可以）约束多列（也就是整个表范围），使用时就是根据实际需求自己选是用列约束还是表约束，其他没啥需要注意的<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Tom,Difference between Table level and Column level constraints?\\[EB/OL\\]\(2010-07-26\),[https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293](https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293)">[4]</span></a></sup>。</p><h1 id="参考资料">参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>codeacg,MySQL表级约束和列级约束[EB/OL](2021-04-28),<ahref="https://blog.csdn.net/qq_48759664/article/details/116240961">https://blog.csdn.net/qq_48759664/article/details/116240961</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>菜鸟教程,SQL约束(Constraints)[EB/OL],<ahref="https://www.runoob.com/sql/sql-constraints.html">https://www.runoob.com/sql/sql-constraints.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://dev.mysql.com/blog-archive/?author=Praveenkumar%20Hulakund">PraveenkumarHulakund</a>,MySQL 8.0.16 Introducing CHECKconstraint[EB/OL](2019-04-26),<ahref="https://dev.mysql.com/blog-archive/mysql-8-0-16-introducing-check-constraint/">https://dev.mysql.com/blog-archive/mysql-8-0-16-introducing-check-constraint/</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Tom,Difference between Tablelevel and Column level constraints?[EB/OL](2010-07-26),<ahref="https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293">https://asktom.oracle.com/ords/f?p=100:11:0::::P11_QUESTION_ID:2665518700346300293</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>后端综合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>MySQL约束</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读SpringBoot源码的心得记录</title>
    <link href="/article/f9025e15.html"/>
    <url>/article/f9025e15.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>前几天在写SpringBoot启动类的时候，本来是要在启动类上加<code>@MapperScan</code>注解的，结果写成了<code>@ComponentScan</code>注解，随后在启动SpringBoot项目的时候发现所有的Bean都没有加载到容器里，当时也是纳闷了一小会儿才发现是注解写错了，导致<code>@ComponentScan</code>注解与<code>@SpringBootApplication</code>注解冲突了，导致<code>@SpringBootApplication</code>默认的包扫描全部失效了，所以容器才没法加载Bean。</p><p>之后我也是好奇为啥会这样，想知道<code>@ComponentScan</code>与<code>@SpringBootApplication</code>的关系以及<code>@SpringBootApplication</code>默认的包扫描到底是啥样的，于是我便看了看注解的相关源码，一下子就想明白了，一边感慨规范的代码看起来确实爽(比吃完泻药都畅通)，一边也觉得学会阅读他人的源码或者文档是一件很重要的事，特别是一些小众的项目，网上相关前辈的经验寥寥无几，只能依靠自己去一点一点阅读官方文档甚至源码，所以在此记录一下我解决问题的过程。</p><p>本文将以<code>@ComponentScan</code>与<code>@SpringBootApplication</code>冲突的问题为基础，详细记录一个小白应该如何通过源码阅读来理清这个问题的根本原因。</p><p>(其实我现在相关的阅读能力也很弱，特别是英文文档，虽然一直在训练自己英文文档阅读能力，但是仍然还是无法像阅读中文文档那样有”回到家“的感觉，有的时候读一个长难句就像便秘一样难受，服了。)</p><h1 id="正文">正文</h1><h2 id="问题引出">1. 问题引出</h2><h3 id="问题描述">1.1 问题描述</h3><p>源码如下所示：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-y26vlkm18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-y26vlkm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.brutik.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Main.class,args);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></div></figure><p>项目目录结构如下：</p><figure><imgsrc="../img/关于如何阅读SpringBoot源码的方法笔记/image-20240213144734852.png"alt="项目目录结构" /><figcaption aria-hidden="true">项目目录结构</figcaption></figure><p>随后启动SpringBoot项目，但是通过规定地址访问项目内容时却均返回<code>404 not found</code>。</p><figure><imgsrc="../img/关于如何阅读SpringBoot源码的方法笔记/image-20240213145300958.png"alt="返回未找到资源错误" /><figcaption aria-hidden="true">返回未找到资源错误</figcaption></figure><h3 id="问题排查与解决">1.2 问题排查与解决</h3><p>经过反复确认访问地址没有问题后，再查看SpringBoot自己的日志打印，发现啥也没有，也就是说明代码和环境也没有问题，那么就可能是自己的逻辑写错了。而返回404的内容又是<code>This application has no explicit mapping for /error</code>，遂推断可能是Controller的Bean根本就没有被加载到容器里，才导致地址没有映射，故开始验证猜测。使用idea自带的工具查看Spring容器里的Bean对象：</p><figure><imgsrc="../img/关于如何阅读SpringBoot源码的方法笔记/image-20240213150449774.png"alt="已加载的Bean对象列表" /><figcaption aria-hidden="true">已加载的Bean对象列表</figcaption></figure><p>发现只有一个自己写Main被加载了，所以猜测是对的。而Bean没被加载一般都是包没有扫描的问题，而我只在Main类上写了扫描包的注解，最后问题解决：<strong><code>@MapperScan</code>注解错写成了<code>@ComponentScan</code>注解</strong>。</p><h2 id="问题深究">2. 问题深究</h2><p>所以为什么加了<code>@ComponentScan</code>会使得<code>@SpringBootApplication</code>扫描包的功能失效呢？只能猜测可能<code>@SpringBootApplication</code>优先级更低，有了<code>@ComponentScan</code>后<code>@SpringBootApplication</code>就被覆盖掉了，而为了验证这个猜想可以通过阅读官方文档或者源码搞懂<code>@SpringBootApplication</code>注解到底干了啥来解决这个疑问。</p><h3 id="源码阅读">2.1 源码阅读</h3><p>首先得强调一点，许多问题其实根本不需要我们去阅读源码特别是像SpringBoot这种体量大、社区活跃度高、使用量也是多得离谱的项目。因为第一，SpringBoot也算是比较复杂的项目了，有的部分靠自己去看源码可能得花大量时间；第二，这种很活跃的项目其实有很多的讲解教程，看大佬们的讲解比我们自己搁那慢慢研究效率会快很多且能学得更深刻。所以看这种类型项目的源码更多其实也是为了学习源码的规范或者是强化自己的代码阅读能力又或者是为了面试(doge)。下面开始进入正文。</p><p>既然是阅读源码，肯定需要一个阅读源码的工具（如果现在还有狠人用记事本看代码敲代码的，那确实是牛逼），而idea无疑是一个很强大的源码阅读工具，各种继承关系、调用关系都可以通过idea看得很清楚。本文也是使用的idea。</p><p><code>Ctrl+鼠标左键</code>查看<code>@SpringBootApplication</code>的注解源码声明（为节省篇幅，部分代码不重要的内容会省略后同）：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-4osobym18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-4osobym18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates a &#123;<span class="hljs-doctag">@link</span> Configuration configuration&#125; class that declares one or more</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Bean <span class="hljs-doctag">@Bean</span>&#125; methods and also triggers &#123;<span class="hljs-doctag">@link</span> EnableAutoConfiguration</span><br><span class="hljs-comment"> * auto-configuration&#125; and &#123;<span class="hljs-doctag">@link</span> ComponentScan component scanning&#125;. This is a convenience</span><br><span class="hljs-comment"> * annotation that is equivalent to declaring &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@EnableAutoConfiguration</span>&#125; and &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@ComponentScan</span>&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Andy Wilkinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.2.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>注释翻译：指明一个配置类，该类声明一个或多个<code>@Bean</code>方法并触发自动配置和组件扫描。这是一个方便的注释，相当于声明<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p><p>当然，从代码中可以看出，实现<code>@SpringBootApplication</code>功能的关键注解是<code>@ComponentScan</code>、<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>。而这里的<code>@ComponentScan</code>就只是为了让两个重要的类不被扫描，故只考虑另外两个到底是干嘛的。</p><p>先看<code>@SpringBootConfiguration</code>：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-smal12m18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-smal12m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates that a class provides Spring Boot application</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Configuration <span class="hljs-doctag">@Configuration</span>&#125;. Can be used as an alternative to the Spring&#x27;s</span><br><span class="hljs-comment"> * standard &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; annotation so that configuration can be found</span><br><span class="hljs-comment"> * automatically (for example in tests).</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Application should only ever include &lt;em&gt;one&lt;/em&gt; &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@SpringBootConfiguration</span>&#125; and</span><br><span class="hljs-comment"> * most idiomatic Spring Boot applications will inherit it from</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@SpringBootApplication</span>&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Andy Wilkinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.4.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>可以从注释中看出，这个注解其实就是用来代替<code>@Configuration</code>注解，套了这么多层娃，结果其实就是为了改一个名字，虽然可读性变好了，但是捏，不好说。</p><p>再来看<code>@EnableAutoConfiguration</code>：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-lo73q3m18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-lo73q3m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Enable auto-configuration of the Spring Application Context, attempting to guess and</span><br><span class="hljs-comment"> * configure beans that you are likely to need. Auto-configuration classes are usually</span><br><span class="hljs-comment"> * applied based on your classpath and what beans you have defined. For example, if you</span><br><span class="hljs-comment"> * have &#123;<span class="hljs-doctag">@code</span> tomcat-embedded.jar&#125; on your classpath you are likely to want a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> TomcatServletWebServerFactory&#125; (unless you have defined your own</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ServletWebServerFactory&#125; bean).</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * When using &#123;<span class="hljs-doctag">@link</span> SpringBootApplication <span class="hljs-doctag">@SpringBootApplication</span>&#125;, the auto-configuration</span><br><span class="hljs-comment"> * of the context is automatically enabled and adding this annotation has therefore no</span><br><span class="hljs-comment"> * additional effect.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Auto-configuration tries to be as intelligent as possible and will back-away as you</span><br><span class="hljs-comment"> * define more of your own configuration. You can always manually &#123;<span class="hljs-doctag">@link</span> #exclude()&#125; any</span><br><span class="hljs-comment"> * configuration that you never want to apply (use &#123;<span class="hljs-doctag">@link</span> #excludeName()&#125; if you don&#x27;t</span><br><span class="hljs-comment"> * have access to them). You can also exclude them via the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> spring.autoconfigure.exclude&#125; property. Auto-configuration is always applied</span><br><span class="hljs-comment"> * after user-defined beans have been registered.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The package of the class that is annotated with &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@EnableAutoConfiguration</span>&#125;,</span><br><span class="hljs-comment"> * usually via &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@SpringBootApplication</span>&#125;, has specific significance and is often used</span><br><span class="hljs-comment"> * as a &#x27;default&#x27;. For example, it will be used when scanning for &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Entity</span>&#125; classes.</span><br><span class="hljs-comment"> * It is generally recommended that you place &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@EnableAutoConfiguration</span>&#125; (if you&#x27;re</span><br><span class="hljs-comment"> * not using &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@SpringBootApplication</span>&#125;) in a root package so that all sub-packages</span><br><span class="hljs-comment"> * and classes can be searched.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Auto-configuration classes are regular Spring &#123;<span class="hljs-doctag">@link</span> Configuration <span class="hljs-doctag">@Configuration</span>&#125;</span><br><span class="hljs-comment"> * beans. They are located using &#123;<span class="hljs-doctag">@link</span> ImportCandidates&#125; and the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> SpringFactoriesLoader&#125; mechanism (keyed against this class). Generally</span><br><span class="hljs-comment"> * auto-configuration beans are &#123;<span class="hljs-doctag">@link</span> Conditional <span class="hljs-doctag">@Conditional</span>&#125; beans (most often using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConditionalOnClass <span class="hljs-doctag">@ConditionalOnClass</span>&#125; and</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConditionalOnMissingBean <span class="hljs-doctag">@ConditionalOnMissingBean</span>&#125; annotations).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> ConditionalOnBean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> ConditionalOnMissingBean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> ConditionalOnClass</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> AutoConfigureAfter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> SpringBootApplication</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>一来就看到个关键字：<code>@AutoConfigurationPackage</code>里面的package，到这一步也基本上就确定这个注解就是用来自动配置包扫描的注解了。但是从注释的这句话：<code>It is generally recommended that you place @EnableAutoConfiguration (if you're not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched.</code>意为：通常建议您将<code>@EnableAutoConfiguration</code>（如果您没有使用<code>@SpringBootApplication</code>）放在根包中，以便可以搜索所有子包和类。可以看出这个注解可以让配置类所在包下的子包以及类加入被扫描的队列。</p><p>再看<code>@AutoConfigurationPackage</code>这个注解：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-czmzrrm18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-czmzrrm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Registers packages with &#123;<span class="hljs-doctag">@link</span> AutoConfigurationPackages&#125;. When no &#123;<span class="hljs-doctag">@link</span> #basePackages</span><br><span class="hljs-comment"> * base packages&#125; or &#123;<span class="hljs-doctag">@link</span> #basePackageClasses base package classes&#125; are specified, the</span><br><span class="hljs-comment"> * package of the annotated class is registered.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.3.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> AutoConfigurationPackages</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>注释中的一句话：<code>When no base packages or base package classes are specified, the package of the annotated class is registered.</code>，翻译出来就是：当基包或者基类没有被指定时，包中被用此注解的类就会被注册生效。基包或者基类就是指要被容器扫描注册的包或者类。</p><p>所以总算找到了答案：只要使用了<code>@ComponentScan</code>注解并加上参数，则就指定了基包或基类，这样会导致<code>@AutoConfigurationPackage</code>不会生效，也就是优先级问题。不过还是好奇是怎么实现包扫描的，从上面可以看出最终的功能实现是靠<code>AutoConfigurationPackages.Registrar.class</code>这个类。</p><p>再看<code>AutoConfigurationPackages.Registrar.class</code>：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-q3d9egm18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-q3d9egm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125; to store the base package from the importing</span><br><span class="hljs-comment">* configuration.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>        register(registry, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title function_">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></div></figure><p>注释写得很明白：该类用于存导入配置中的基包值。而从类中的方法里可以看到实际是<code>PackageImports</code>这个类负责获取基包名。</p><p>再看<code>PackageImports</code>：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-8o149um18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-8o149um18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Wrapper for a package import.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageImports</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; packageNames;<br><br>    PackageImports(AnnotationMetadata metadata) &#123;<br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> AnnotationAttributes<br>            .fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), <span class="hljs-literal">false</span>));<br>        List&lt;String&gt; packageNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(attributes.getStringArray(<span class="hljs-string">&quot;basePackages&quot;</span>)));<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; basePackageClass : attributes.getClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)) &#123;<br>            packageNames.add(basePackageClass.getPackage().getName());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (packageNames.isEmpty()) &#123;<br>            packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));<br>        &#125;<br>        <span class="hljs-built_in">this</span>.packageNames = Collections.unmodifiableList(packageNames);<br>    &#125;<br><br>    List&lt;String&gt; <span class="hljs-title function_">getPackageNames</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.packageNames;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> || getClass() != obj.getClass()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.packageNames.equals(((PackageImports) obj).packageNames);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.packageNames.hashCode();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Package Imports &quot;</span> + <span class="hljs-built_in">this</span>.packageNames;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></div></figure><p>重点关注其构造方法，可以看到构造方法里先是尝试从<code>@AutoConfigurationPackage</code>注解的元信息中获取基包值，并作了个判断，如果没有获取到就使用注解所在包作为基包。至于怎么判断<code>@ComponentScan</code>是否存在的具体方法，经过查找应该是在<code>AutoConfigurationImportSelector</code>类中定义的，不过我也不想看了，因为各种类名、方法名太长了，看得我眼睛疼，意思意思就行了。</p><h2 id="总结">3. 总结</h2><p>从以上可以看出，如果你头铁直接去读源码，其实也没多少技巧，就是靠注释再结合各种类名、方法名去理解甚至去猜测源码的具体意思，如果遇到一些写得烂的代码，这个时候估计得开始咒作者全家了，因为基本上只能去嗯猜，全靠自己的经验。其实SpringBoot的源码在我的角度也只是一些关键的地方注释写得非常清楚明白，但是在一些不重要的方法或者类上也是看得人脑壳疼，一些类名或者方法名真的是又臭又长，比如：<code>getAutoConfigurationImportListeners</code>这种，来一两个还好，但是满屏都是这种是真的英语非母语者不友好，看得人眼睛是真的疼，虽然表达的意思清晰明了，但是信息密度太低了，来张图感受一下：</p><figure><imgsrc="../img/关于如何阅读SpringBoot源码的方法笔记/image-20240213212844741.png"alt="眼睛疼" /><figcaption aria-hidden="true">眼睛疼</figcaption></figure><p>以上缺点我感觉也无解，要么就用缩写，更让人崩溃。不过好在每个方法代码长度都很短，很符合<code>Robert C. Martin</code>那老计说的“代码整洁艺术”，只要代码长度短，写得再烂也容易读懂。</p><p>所以，放弃头铁，不要动不动就去读源码，有这精力去研究官方文档或者各路为爱发电的大神出的各种博客文章，早出师了，比读源码强一万倍，除非要去学习代码的各种命名规范、继承关系的逻辑等等，否则源码？狗都不看！</p><p>好困，写不动了，睡觉。</p>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>后端综合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝赛尔曲线的数学原理与工程运用</title>
    <link href="/article/bffca486.html"/>
    <url>/article/bffca486.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>之前在学习安卓开发涉及到图形绘制时，发现某个类提供了一个方法可以用来绘制曲线，后来那个方法绘制的曲线就是贝赛尔曲线。当时听着这个名字感觉很牛X的样子，然后又进一步了解了到底什么是贝塞尔曲线，了解完后我直呼卧槽。</p><p>所以本文诞生，就是单纯想写一篇贝塞尔曲线的介绍文。本文将简短地介绍贝塞尔曲线的发展历史、数学原理，最后会给出几个贝塞尔曲线的相关应用示例。</p><h1 id="正文">正文</h1><h2 id="一.-贝赛尔曲线简述">一. 贝赛尔曲线简述</h2><p>贝塞尔曲线（英语：Béziercurve）最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法所开发，他用稳定数值的方法求出了贝塞尔曲线。但贝塞尔曲线于1962年才由法国工程师皮埃尔·贝塞尔（PierreBézier）所广泛发表，他借用贝塞尔曲线完成了汽车的主体设计<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="维基百科,贝塞尔曲线\\[EB/OL\\],[https://zh.wikipedia.org/zh-cn/貝茲曲線](https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A)">[1]</span></a></sup>。</p><p><img src="../img/贝赛尔曲线的数学原理与工程运用/bezier_curve.png" alt="贝赛尔曲线示例"  /></p><p>贝塞尔曲线有着很多特殊的性质，其如今已是计算机图形学及相关领域中常使用的重要参数曲线，在诸如计算机字体设计、动画设计、机器人运动平滑控制中都有运用到贝赛尔曲线。贝塞尔曲线可以组合起来形成贝塞尔样条曲线，或者推广到更高维度以形成贝塞尔曲面。</p><p><img src="../img/贝赛尔曲线的数学原理与工程运用/bezier_surfaces.png" alt="贝塞尔曲面示例"  /></p><p>这里介绍两个网站，一个是<ahref="https://www.jasondavies.com/animated-bezier/">贝赛尔曲线动画</a>，从该网站给出了几个贝赛尔曲线动态图演示；另一个是<ahref="https://www.desmos.com/calculator/cahqdxeshd?lang=zh-CN">贝赛尔曲线demo</a>，在该网站可以手动改变端点来感受贝赛尔曲线的变化。</p><h2 id="二.-数学公式简述与推导">二. 数学公式简述与推导</h2><p>贝赛尔曲线的通式实际上是一个与二项展开式有关的一个多项式，本文仅在通项的推导上做出简单的演示，对于贝塞尔曲线的其他性质不做讨论。下面将从一次开始逐步推导出N次的贝塞尔曲线。</p><h3 id="一次贝赛尔曲线">2.1 一次贝赛尔曲线</h3><p>一次贝塞尔曲线又可以叫做线性贝塞尔曲线，因为一次的贝塞尔曲线实际上就是两个点的连线，即一条直线段，如图：</p><figure><imgsrc="../img/贝赛尔曲线的数学原理与工程运用/image-20240211172605127.png"alt="一次贝赛尔曲线" /><figcaption aria-hidden="true">一次贝赛尔曲线</figcaption></figure><p>图中有一条由点P₁(6,6)、点P₂(2,2)连接形成的直线段，P₀为该线段上的动点，运动方向由P₂到P₁,图中红色线段即为P₀的运动轨迹。可知P₀的轨迹方程为：<span class="math display">\[B_{1}(t)=P_{2}+(P_{1}-P_{2})t,t\in[0,1]\]</span></p><p>化简得：</p><p><span class="math display">\[B_{1}(t)=P_{1}t+P_{2}(1-t),t\in[0,1]\]</span></p><p>注意上式中的P₁、P₂代表一个二元式，表示了一个坐标如P₁为(2,2)，<strong>即B₁(t)就是P₀坐标的变化方程(轨迹坐标方程)，而这个轨迹方程即为一个一次贝赛尔曲线的轨迹方程，其中t为控制P₀在线段上运动范围的变量，其值实际代表了线段P₀P₂与线段P₁P₂的长度比值</strong>。将P₁、P₂的坐标值代入，可得以上示例图中的贝赛尔曲线方程为：<span class="math display">\[B_{1}(t)=(6,6)*t+(2,2)*(1-t)=(2+4t,2+4t),t\in[0,1]\]</span></p><h3 id="二次贝赛尔曲线">2.2 二次贝赛尔曲线</h3><p>二次贝赛尔曲线即其方程的最高次为二次。如图，在平面上任取三点并依次用线段连接：</p><figure><imgsrc="../img/贝赛尔曲线的数学原理与工程运用/image-20240211213016213.png"alt="三点连接而成的两条线段" /><figcaption aria-hidden="true">三点连接而成的两条线段</figcaption></figure><p>这里为了方便取P₁(6,6)、P₂(2,2)、P₃(10,2)。设t为一个变量，且t∈[0,1]。在线段P₂P₁、P₁P₃两条线段上分别取A、B共两点，且令各线段长度满足以下关系：<span class="math display">\[\frac{P_{2}A}{P_{2}P_{1}}=\frac{P_{1}B}{P_{1}P_{3}}=t\]</span></p><p>当t=0.5时，如图：</p><figure><imgsrc="../img/贝赛尔曲线的数学原理与工程运用/image-20240211214107104.png"alt="t=0.5时的线段图" /><figcaption aria-hidden="true">t=0.5时的线段图</figcaption></figure><p>最后，在线段AB上取一点P₀，使其满足： <span class="math display">\[\frac{AP_{0}}{AB}=t\]</span></p><p>同样当t=0.5时，如图所示：</p><figure><imgsrc="../img/贝赛尔曲线的数学原理与工程运用/image-20240211214935636.png"alt="t=0.5时的线段图" /><figcaption aria-hidden="true">t=0.5时的线段图</figcaption></figure><p>实际上此时单独看线段AB上的P₀其实与一次贝塞尔曲线中的P₀一样。同时还可以看出，如果单独看P₂P₁上的A点、P₁P₃上的B点，实际上都是一次贝赛尔曲线的情况，而二次贝赛尔曲线就是在一次贝赛尔曲线的基础上再将线段的端点都限制在一次贝赛尔曲线轨迹的条件下，由此原P₀点的运动轨迹就变为了二次贝赛尔曲线，如图：</p><figure><imgsrc="../img/贝赛尔曲线的数学原理与工程运用/image-20240211212922708.png"alt="二次贝赛尔曲线" /><figcaption aria-hidden="true">二次贝赛尔曲线</figcaption></figure><p>最后求P₀的轨迹方程，也就是二次贝赛尔曲线的方程。思路为先求分别求出点A与点B的轨迹方程，最后再借其求出点P₀的轨迹方程：</p><p>因为点A与点B的轨迹方程分别为： <span class="math display">\[\begin{cases}a(t)=P_{2}+(P_{1}-P_{2})t\\b(t)=P_{1}+(P_{3}-P_{1})t\end{cases},t\in[0,1]\]</span></p><p>故点P₀的轨迹方程为： <span class="math display">\[B_{2}(t)=a(t)+[b(t)-a(t)]t\]</span></p><p>化简得： <span class="math display">\[B_{2}(t)=2t(1-t)P_{1}+(1-t)^2P_{2}+P_{3}t^2\]</span></p><p>上式有点眼熟？没错！去掉P₁、P₂、P₃的点坐标，得到一个多项式： <spanclass="math display">\[f(t)=(1-t)^2+2t(1-t)+t^2=[t+(1-t)]^2\]</span></p><p>这不就是一个二项展开式吗！</p><h3 id="三次贝赛尔曲线">2.3 三次贝赛尔曲线</h3><p>从上面的推导其实可以看出，三次贝赛尔曲线实际是在二次贝赛尔曲线的基础上将线段的三个点约束在三个一次贝塞尔曲线上，由此原有的二次贝塞尔曲线轨迹就变为了三次贝塞尔曲线。所以三次贝塞尔曲线的方程可以为：<span class="math display">\[B_{3}(t)=P_{0}(1-t)^3+3P_{1}t(1-t)^2+3P_{2}t^2(1-t)+P_{3}t^3,t\in[0,1]\]</span></p><p>可以看出去掉点坐标后,实际上就是<code>[t+(1-t)]³</code>的展开式。</p><h3 id="n次贝塞尔曲线">2.4 N次贝塞尔曲线</h3><p>由以上可得知，实际上一次贝赛尔曲线可以通过约束升阶为多次贝赛尔曲线，当然多次贝塞尔曲线也可以不停降次至一次贝塞尔曲线。同时其与点坐标无关的通式实际上是一个二项展开式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="FrancisZhao,曲线篇: 贝塞尔曲线\\[EB/OL\\]\(2020-04-28)，[https://zhuanlan.zhihu.com/p/136647181](https://zhuanlan.zhihu.com/p/136647181) ↩">[2]</span></a></sup>，例如N次贝赛尔曲线对应<code>[t+(1-t)]ⁿ</code>。故其通项可以推导为：</p><p>给定多个定点P₀、P₁、P₂、P₃、...、Pn，则其贝赛尔曲线为： <spanclass="math display">\[B_{n}(t)=\sum^{n}_{i=0}C^{i}_{n}P_{i}(1-t)^{n-i}t^{i},t\in[0,1]\]</span></p><h2 id="三.-相关应用示例介绍">三. 相关应用示例介绍</h2><p>实际上，许多绘图工具都会用贝赛尔曲线，例如PS里拉伸图片时就是用的贝赛尔曲线来约束图片变化路径。本来准备演示一下PS中的贝塞尔，但是失败了。完。</p><h1 id="参考文献">参考文献</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>维基百科,贝塞尔曲线[EB/OL],<ahref="https://zh.wikipedia.org/zh-cn/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A">https://zh.wikipedia.org/zh-cn/貝茲曲線</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>FrancisZhao,曲线篇:贝塞尔曲线[EB/OL](2020-04-28)，<ahref="https://zhuanlan.zhihu.com/p/136647181">https://zhuanlan.zhihu.com/p/136647181</a>↩︎ <a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机理论</category>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>贝塞尔曲线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring,码农滴自我救赎之路</title>
    <link href="/article/b4340977.html"/>
    <url>/article/b4340977.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="正文">正文</h1><p>今天仍然是学习Spring框架的一天，又一次重温了Spring框架存在的意义，听着听着自己却走神了，又想起了N年前那个玩着天天酷跑却老想着开挂的小学僧，不知道是为了装比还是为了不劳而获，我自己也记不清自己的目的了，反正误打误撞了解到了“黑客”这个群体，至今我的QQ空间里还转载着一篇仅个人可见的文章《密码心理学，看看黑客是如何来破解密码的》，然后顺理成章地打开了新世界的大门——编程，听起来就是一件非常牛X的一件事，在我的幻想中，编程可以让人充分发挥自己的创造力，随心所欲地去实现自己的想法，创造出各种各样属于自己的事物。</p><p>回到Spring，似乎Spring为程序员减轻了大量的负担，但这就像是Windows操作系统与普通用户的关系，普通用户只能机械地点着一个个“精美的按钮”，而底层的无数细节操作系统全部都对用户“隐瞒”了——想要用尽可能少的精力来获得尽可能多的回报结果，必然会付出代价，这个代价就是将多数处理的“权力“放弃，对于我来说，这就像是放弃了自己的主动性，使自己彻底沦为一个”提线木偶“，表面上似乎自己是全局掌控者，却不知自己实际上只是一个可有可无的角色。Spring让”创造“变得简单，但也让”创造“变为了”制造“，让编程失去了渐渐失去了原有的创造美，Spring让编程变成了一个体力活，而不是一个脑力活。</p><p>后注：今天是2024年4月13日，经历了二战失败，自我怀疑，迷茫未来等一系列复杂的心理活动变化后，我终究还是放弃了挣扎，或者是表面放弃了挣扎，我只是突然不知道自己到底想要什么，互联王的信息太多太杂，我羡慕一些人的自由散漫，也羡慕一些人的纸醉金迷，羡慕一些人能够无欲无求地快乐着或者，也羡慕一些人生来就在罗马，不用担心那点狗屁窝囊费，更羡慕那些通过自己努力奋斗最后成功了的人。两个月前，我独自一人坐在十平米的小屋里，关着窗，即使是白天周围也是一片漆黑，让我有点看不清墙边上挂着的到底是什么东西，我一直望着它，发着呆。一个月后，我并没有投多少简历，更没有面几次试，但是我的内心被绝望填满了，我发现我好像看不到自己的未来了。现在，我终于还是匆匆投递了一个网上全是差评的公司，并签了合同，入了职，当然这个岗位也并不是我期望的开发岗。今天我整理着电脑里的一些文档数据，看到了这篇文章，这是我三个月前在学Spring时发的牢骚（而且写一半就不想写了），当时居然还在抱怨Spring管得太多了，哈哈，想哭都不知道以什么理由哭。</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>行业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>码农</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EPIC无法启动(windows10&amp;11)</title>
    <link href="/article/22e7158c.html"/>
    <url>/article/22e7158c.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>EPIC不知道抽什么风，又无法启动了，其实在很久以前其实就遇到了这个问题（某次windows版本更新后EPIC就启动不了了），我就在想到底什么情况。当然想了半天也没想出一个所以然，以下是我关于解决epic无法启动的一个猜想过程（乱想🫥）。点击👨‍🔧<ahref="#解决方法总结">解决方法</a>可以快速直达最终的解决方案。</p><h1 id="正文">正文</h1><h2 id="第一步epic启动">第一步，EPIC启动！</h2><p>双击EPIC快捷方式图标启动！</p><p>如下图，经过检查，可以看到默认的快捷方式使用的<code>WIN32</code>文件夹下面的启动器：</p><figure><img src="../img/EPIC无法启动-windows10-11/image-20231213113512209.png"alt="image-20231213113512209" /><figcaption aria-hidden="true">image-20231213113512209</figcaption></figure><h2 id="第二步静置等待结果">第二步，静置等待结果！</h2><p>静置电脑十分钟后，没有任何反应，遂打开任务管理器：</p><figure><img src="../img/EPIC无法启动-windows10-11/image-20231213113916080.png"alt="image-20231213113916080" /><figcaption aria-hidden="true">image-20231213113916080</figcaption></figure><p>可以看出有很多一样的进程名都在运行，而且对CPU的利用率都是零，我突发奇想，不会是启动器损坏了，然后不知道自己要调多少次相关的启动服务模块了吧？不会死锁了吧？那我就试试手动强制打断“死锁”，杀掉相同名称的进程，只留一个同名的。</p><h2id="第三步尝试解决问题已表面解决">第三步，尝试解决问题！（已表面解决）</h2><p>先干掉管理员（system）的试试，结果瞬间另一个进程就被唤醒了，然后CPU也活了（第五行变成了03）：</p><figure><img src="../img/EPIC无法启动-windows10-11/image-20231213114525070.png"alt="image-20231213114525070" /><figcaption aria-hidden="true">image-20231213114525070</figcaption></figure><p>偶买噶，然后瞬间EPIC的用户界面就跳出来了：</p><figure><img src="../img/EPIC无法启动-windows10-11/image-20231213114506188.png"alt="image-20231213114506188" /><figcaption aria-hidden="true">image-20231213114506188</figcaption></figure><p>喜大普奔，到底是什么原因，我是真不知道，我尝试过将EPIC重装，并没有任何用，升级了windows，也没有用。反正用上面的方法就有用了，把管理员的<code>EpicOnlineServices.exe</code>手动给他干掉就可以了。</p><h2 id="解决方法总结">解决方法总结</h2><p>解决办法：双击打开epic，随后打开任务管理器，手动停止管理员（system）的<code>EpicOnlineServices.exe</code>进程，大功告成。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>工具的安装、配置或使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>EPIC</tag>
      
      <tag>EPIC平台无法启动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅浅讨论一下现今人们的网络隐私保护问题</title>
    <link href="/article/a6934378.html"/>
    <url>/article/a6934378.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>前段时间老是收到一些骚扰电话，虽然我可以选择不接，但是时不时来个莫名其妙的电话还是让人感觉很不爽，而且这些电话无非就是叫你买房、投资或者贷款等各种营销电话。我本来身上就没几个子儿，你叫我来贷款还说得过去，你叫我投资炒股买房是啥意思，我有那个钱给你吗？不过这样看来，这些不知道怎么拿到我电话号码的人估计也就知道我的电话号码了，或者还知道我的名字，对于我其他的信息大概率是不了解的。</p><p>在以前，我也并不没有很在意这些陌生电话，但是随着这些年我在网上使用个人信息的场景也越来越多，这些陌生电话也越来越多，我便开始有点反感这种现象，于是我开始好奇这些信息到底怎么被泄露出去的。我开始在网上寻找答案，但是并没有看出个所以然，直到有一天我误入了某电报群（其实是闲得没事到处搜索），然后就该群里发现有大量私人信息被打包出售，当时没见过世面的我是第一次真正触摸到这种黑产，直接震惊了我一百年——我震惊的不是这种产业居然真的存在，而是它居然可以这么轻松地、堂而皇之地在我面前出现了。我当时就心想：乖乖，这么嚣张？我试着点进一些预览的信息图，里面对某人个人信息售卖范围包括其性别、姓名、使用过的电话号码集、住址、工作地、身份证号码，这还只是预览的信息，里面就有几百个人的这类信息。看完后我只能直呼卧槽，突然就觉得自己好像一直是在整个网络世界裸奔一样。</p><p>后来有意地去接触这方面的东西，我开始意识到这个问题的严重性。如今，对于大部分中国人来说，不论是工作还是娱乐的原因，网络，已经成为一个离不开的东西，但是随着”网络生态“的野蛮扩张，网络隐私泄露实际上已经成为了一个不可忽视的严重问题，尽管大部分人实际上对此都不熟悉甚至并不在意，但我想说的是事实却是大部分的人对这个问题是无能为力。所以我决定写一篇文章，来尝试粗浅地解决这个问题，或者说是“尽量避免”。</p><p>这篇文章只是一片引文，该文章仅介绍我对于一些隐私信息的看法，包括常见的隐私信息及其重要性等级，同时还会举出一些易用的保护隐私的方法。根据这篇文章，我可能还会出一期专栏，主要涉及如何通过公用网络“人肉”一个人以及对应的防御措施、各个网络公司在隐私保护方面的信息事件等。</p><div class="note note-warning">            <p>注意：文章所有内容只是个人观点，仅供参考</p>          </div><h1 id="正文">正文</h1><h2 id="一什么是隐私信息">一、什么是隐私信息</h2><p>在进行所有关于隐私信息的其他想法前，显然应该对隐私信息有一个较清晰的概念。</p><p>先看看法律对“个人隐私”给出的定义：个人隐私是指公民个人生活中不愿为他人（一定范围以外的人）公开或知悉的秘密，且这一秘密与其他人及社会利益无关。判断信息是否属于个人隐私核心就在于，公民本人是否愿意他人知晓，以及该信息是否与他人及社会利益相关。如个人日记，身体缺陷，个人私密照片等<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="百度百科,个人隐私[EB/OL],[https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E9%9A%90%E7%A7%81/7128166](https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E9%9A%90%E7%A7%81/7128166)">[1]</span></a></sup>。所以判断什么是隐私信息最重要的就是看信息所属方是否愿意公布该信息。</p><p>但是，想要精确地确定某信息是属于隐私信息，其实还是有难度的，所以笔者在这里只能结合一些新闻信息以及高强度冲浪所得的经验，给出自己的隐私信息定义以及范围标准。</p><h3 id="定义">1.1 定义</h3><p>在明确定义前，先规定一些粗糙但可用的概念以避免歧义（不用看也行，一般也不会有歧义）：</p><ul><li><strong>信息</strong>：一切能被人所感受到并转化为自己认知一部分的东西，例如一段文字就可以被叫做一段信息，各种信息之间可以随意组合形成一个新的信息。</li><li><strong>信息复制</strong>：指由一段信息创造出另一段相关的信息，两段信息有高度的重合性，被复制出来的信息就叫做复制信息。</li><li><strong>信息源</strong>：指在进行信息复制时所使用的信息，例如利用A复制产生B，则A就叫做B的信息源，注意复制信息可以由多段信息组成，所以也可以有多个信息源。</li><li><strong>信息根源</strong>：从复制信息开始一直向上寻找信息源，直至寻找到没有信息源的信息源，即为信息根源。这里假设信息根源总是存在的，可以将信息根源看作是人最初的第一个卵细胞，之后所有细胞都是直接或者间接由它分裂而来，而且最初的卵细胞只会有一个。各种信息根源可以组成形成一个新的信息根源。</li><li><strong>信息生产者</strong>：即某一信息的创造人（生产者）。</li><li><strong>信息所属者</strong>：指信息根源的拥有者。</li></ul><p>以上概念主要都是为了描述“<strong>信息所属者</strong>”这个概念。如果说一个人是某个信息的“<strong>信息所属者</strong>”，那么就可以确定这个信息与这个人唯一对应，从而通过这个信息来推断到这个人。就像是老王的身份证号码是<code>110110</code>，有一天我路过某个洗脚店，突然看见店外的LED屏上滚动播放着“感谢身份证号为110110的客户在本店消费累计超过一万元”这种信息，我立马就能通过这信息想到老王这小子不简单。理解信息所属者的概念后再进入正题。</p><p>这里笔者假设所有人都有这么一个观念：对于越陌生的人，人们就越不想暴露过多的个人相关信息给对方，反之就越能接受个人相关信息的暴露程度，这里的个人相关信息包括方方面面，例如：个人基本信息、个人爱好、个人平时活动范围等等，而如果我们对一个人暴露太多个人相关信息，那么对方就能通过一些手段筛选出关键信息来假设或者是确定我们就是这些信息的所属者，从而通过这些信息来更精确地了解我们的方方面面。</p><p>随后，再对所有我们会遇到的人的陌生程度划分到六个等级：</p><div style="margin:0 auto;display:table"><table><thead><tr class="header"><th>等级</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>等级一：亲密无间</td><td>几乎无隐私可言</td></tr><tr class="even"><td>等级二：亲密</td><td>保留少部分隐私</td></tr><tr class="odd"><td>等级三：一般</td><td>保留正常隐私</td></tr><tr class="even"><td>等级四：疏远</td><td>保留大部分隐私</td></tr><tr class="odd"><td>等级五：陌生</td><td>保留绝大部分隐私</td></tr><tr class="even"><td>等级六：极度陌生</td><td>根本不想接触</td></tr></tbody></table></div><p>而隐私信息就是指：人们希望对于所有陌生程度为疏远及以下的人群能够隐藏的信息，而这些信息实际上就是指属于我们的信息根源，例如类似于身份证号、电话号码等等的信息。因为我们是这些信息根源的拥有者，其余人可以通过这些信息根源来逐步了解我们的个人姓名、住址、家庭关系等等各种相关个人信息，从而让我们的个人相关信息过多地被暴露，但我们并不希望这任何的一切能够发生。</p><h3 id="隐私信息泄露">1.2 隐私信息泄露</h3><p>再通过“盒攻击”（即指开盒，即指在网络上公开曝光他人隐私的行为，是一种网络暴力行为<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="百度百科,开盒[EB/OL],[https://baike.baidu.com/item/%E5%BC%80%E7%9B%92/58943997](https://baike.baidu.com/item/%E5%BC%80%E7%9B%92/58943997)">[2]</span></a></sup>）常见的攻击范围来进一步帮助确定常见隐私信息范围。如下面几张图是我平时搜集到的部分开盒攻击信息（部分信息已打码）：</p><figure><imgsrc="../img/浅浅讨论一下现今人们的隐私保护问题/image-20240915222337688.png"alt="B站评论开盒" /><figcaption aria-hidden="true">B站评论开盒</figcaption></figure><figure><imgsrc="../img/浅浅讨论一下现今人们的隐私保护问题/image-20240915223312392.png"alt="电报群开盒" /><figcaption aria-hidden="true">电报群开盒</figcaption></figure><p>以上只是呈现部分开盒攻击的截图，这些开盒攻击基本都会公布暴露受害人以下隐私信息：</p><ul><li>姓名、性别、样貌、民族、身份证号、详细家庭住址等基本身份证上的完整信息</li><li>家庭关系与电话号码，例如父亲、母亲姓甚名谁，有什么亲朋好友以及相关电话号码</li><li>网络社交媒体账号信息以及相关平台信息，例如QQ、微信、支付宝、小红书、抖音、快手账号以及相关的游戏账号、直播账号</li><li>学历信息，大多为高中及以后的学历信息</li><li>工作经历（较少）</li><li>医院就诊记录</li><li>其余各种校园以及社会活动，例如什么时候参加了什么学校社团，任职如何，什么时候参加了哪个社区活动，干了什么</li></ul><p>所以以以上为基准，可以视为常见隐私信息</p><h3 id="何为信息">1.何为信息</h3><h3 id="何为隐私信息">2.何为隐私信息</h3><p>百度百科上对该词的解释中将其解释为：意思是不愿公开的信息。这种解释确实很有道理，因为单从字面意思来看，“隐”就是隐去，“私”就是私密，连起来就是隐去私密，有点主动的意味，所以隐私就是一个人不愿意主动公开的信息。但是</p><h3 id="隐私信息重要性分级">3.隐私信息重要性分级</h3><h2id="二哪些隐私信息容易出现网络上">二、哪些隐私信息容易出现网络上</h2><p>真实姓名</p><p>真实面容</p><p>真实住址</p><p>手机号码</p><p>QQ、QQ邮箱、微信号、年龄、性别、学校</p><p>购物习惯</p><p>饮食习惯</p><p>娱乐习惯</p><p>个人主要性格</p><p>个人人际关系网络</p><p>父母关系情况</p><h2id="三常见的网络隐私信息泄露途径">三、常见的网络隐私信息泄露途径</h2><h3 id="新闻报告统计每年有xxxx">3.1 新闻报告统计：每年有xxxx</h3><h3 id="快递-姓名电话住址">快递-&gt;姓名、电话、住址</h3><h3 id="外卖">外卖</h3><h3 id="敏感信息读取">敏感信息读取</h3><h3 id="qq">QQ</h3><h3 id="微信">微信</h3><h2id="四在网络上怎样保护自己的网络信息">四、在网络上怎样保护自己的网络信息</h2><p>QQ：如无特殊，不授权通讯录、关闭QQ号查找、手机号查找</p><p>微信：关闭手机号查找</p><h1 id="附录">附录</h1><h3 id="附录1">附录1</h3><h3 id="附录2">附录2</h3><h1 id="参考资料">参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度百科,个人隐私[EB/OL],<ahref="https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E9%9A%90%E7%A7%81/7128166">https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E9%9A%90%E7%A7%81/7128166</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>百度百科,开盒[EB/OL],<ahref="https://baike.baidu.com/item/%E5%BC%80%E7%9B%92/58943997">https://baike.baidu.com/item/%E5%BC%80%E7%9B%92/58943997</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>待完成</tag>
      
      <tag>网络隐私</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-关于分组交换为什么可以比报文交换的传送效率更高的原因理解</title>
    <link href="/article/294b0346.html"/>
    <url>/article/294b0346.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="正文">正文</h1><p>前段时间学习了分组交换与报文交换，其中对分组交换的优点描述有一个“特定相同条件下比报文交换传输效率更高”，我当时第一眼看到就想：在两者传输数据量相同、所有传输节点传输速率相同的条件下，一个是一次性传输，一个是分为多个组多次传输，直觉上来看两者传输时间应该是差不多的。但是仔细想，才发现并不是这样，造成这种错误的原因就是只考虑了两个节点的传输过程（而这时候时间也确实相等）。</p><p>之所以分组交换传输效率高（注意分组不是一定就比报文高），考虑最简单的情况，在传输两端有一个路由器，发送端和路由器带宽是一个报文大小，假设发送一个报文花费的时间为t，只考虑发送时延，计算发送一个报文到接收端的时间：</p><p>①如果一次性传输一个报文，则总过程为第一个报文准备t时间发送到路由器，在t时间内路由器空闲，随后路由器再准备t时间发送到接收端，总共会花费2t的时间传输到接收端，其中路由器空闲t时间。</p><p>②如果一次只传输半个报文，则总过程为第一个半报文准备0.5t时间发送到路由器，在0.5t时间内路由器空闲，随后路由器准备0.5t时间将第二个半报文准备0.5t发送给接收端，随后第二个半报文也被准备好发送给了路由器，随后路由器再准备0.5t时间发送到接收端，总共花费1.5t时间，其中路由器空闲时间0.5t。</p><p>可以看出，分组交换之所以比报文交换传输效率高，是因为分组交换可以快速使所有路由器同时处于工作状态，从而提高传输效率，而且是成倍增长。</p>]]></content>
    
    
    <categories>
      
      <category>计算机理论</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>计算机网络</tag>
      
      <tag>分组交换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用文件资源管理器目录栏快速git bash</title>
    <link href="/article/ab9a7ee.html"/>
    <url>/article/ab9a7ee.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>自从升级了win11，那个二级右键菜单越用越不得劲。本来就要多点一下，多点那一下还要一卡一卡的。终于还是在我用右键gitbashhere的时候，我实在忍不住了——太慢太卡了！以前我0.5秒就可以打开，现在需要1.5秒，这能忍？</p><p>遂CV大法开启，看看网上能有什么快捷教程可以用的（我记得以前装git的时候看到了一个类似教程，但是我对此并不感冒），结果搜了一圈，全是一些乱七八糟牛头不对马嘴的答案，最终放弃，只能自己创造答案。</p><p>本教程主要实现的功能为：在文件资源管理器中的目录栏键入关键字后，快速启动“gitbash here”。注意：本教程仅适用于windows10+系统。</p><h1 id="正文">正文</h1><h2 id="一快速实现">一、快速实现</h2><h3 id="创建批处理任务脚本bat文件">1.创建批处理任务脚本（bat文件）</h3><p>在git的安装目录下（为什么是这里？因为方便，随便甩哪也无所谓）创建一个txt文件，将以下代码修改后复制粘贴到文件中：</p><figure class="highlight shell"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-ka5oiam18zzwd7"></i><span>SHELL</span><div class="collapse show" id="collapse-ka5oiam18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">start D:\program&quot; &quot;files\Git\git-bash.exe<br></code></pre></td></tr></table></div></figure><p>需修改部分为<code>D:\program" "files\Git\git-bash.exe</code>，将这里改为你自己的git-bash.exe路径，中间有个<code>" "</code>是表示此处有空格。保存文件后，修改后缀名为<code>bat</code>，文件名修改为<code>gbh</code>。</p><h3 id="添加系统环境变量">2.添加系统环境变量</h3><p>进入设置，在设置搜索框搜索“高级系统设置”，进入“高级系统设置”：</p><figure><imgsrc="../img/利用文件资源管理器目录栏快速git-bash/image-20230904121523307.png"alt="进入高级系统设置" /><figcaption aria-hidden="true">进入高级系统设置</figcaption></figure><p>如上图，点击<code>环境变量</code>开始添加环境变量。进入后可以看到一个是用户变量窗口，一个是系统变量窗口。</p><p>选择系统变量窗口下的<code>新建变量</code>，变量名填<code>gbh</code>（可以随便写，但是需要和上一步中的文件名保持一致），变量值填git-bash.exe的上一级目录，例如<code>D:\program" "files\Git\</code>，点击确定保存。</p><p>随后在系统变量窗口里找到变量名为<code>Path</code>的变量，双击后进入变量详情页，点击<code>新建</code>创建一个变量值，值为<code>%gbh%</code>。注意三个<code>gbh</code>名中任意一个发生了修改例如改成git-bash-here，都要保证另外两个同时修改为git-bash-here。</p><p>操作完后，点击确定保存。注意不点击确定是保存不了的。</p><h3 id="开始使用">3.开始使用</h3><p>打开资源管理器，在任意目录下的目录栏输入<code>gbh</code>即可快速实现右键中的<code>git bash here</code>。</p><figure><imgsrc="../img/利用文件资源管理器目录栏快速git-bash/image-20230904122836107.png"alt="目录栏里调用脚本" /><figcaption aria-hidden="true">目录栏里调用脚本</figcaption></figure><h2 id="二原理粗略解释">二、原理粗略解释</h2><p>具体什么原理我也不知道，因为这是我自己试出来的。因为我就只知道一个在目录栏里输入cmd就可以快速打开cmd。于是我就顺藤摸瓜，发现目录栏里的关键字可以和环境变量里的<code>Path</code>变量值匹配，而且还可以根据这个变量值自动寻找这个值对应路径下面的bat运行，其中bat的名字是和关键字是一样的。关于bat文件中那段代码<code>start</code>意思就是运行对应文件的意思。就这样了，其他具体的也懒得去深究了，因为对我没太大帮助。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>工具的安装、配置或使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>git bash</tag>
      
      <tag>系统环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯视频会员自动签到-基于金山在线文档定时任务</title>
    <link href="/article/f522c69d.html"/>
    <url>/article/f522c69d.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>不知道从什么时候起，万恶的腾讯视频改了会员成长机制，而后以前躺着就能获得会员成长值任务的时代一去不复返。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230820110036473.png"alt="腾讯视频会员成长机制改版" /><figcaption aria-hidden="true">腾讯视频会员成长机制改版</figcaption></figure><p>现在，作为尊贵的VIP用户，居然只能靠每天手动签到去获得成长值，有时甚至只有几个点，你隔这打发叫花子呢？就这还想让我来给你亲自签到？我二话不说，直接发动CV大招，百度+谷歌+CSDN+github四件套，轻松解决自动签到问题，麻麻再也不用担心我的会员成长值涨得慢啦！</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230820111042476.png"alt="开启自动签到后，轻松升级V7不是梦" /><figcaptionaria-hidden="true">开启自动签到后，轻松升级V7不是梦</figcaption></figure><p>注意，本文章中实现的自动签到功能基于js编写（完整代码见附录<ahref="#完整实现代码">完整实现代码</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="腾讯视频云签到,[EB/OL\\]\(2023-06-04),[https://blog.csdn.net/lvhaoye/article/details/119963357](https://blog.csdn.net/lvhaoye/article/details/119963357)">[1]</span></a></sup>），并由金山在线文档中的定时任务实现运行（免费、稳定且给力熬），实现原理是利用cookie完成身份验证并访问签到接口，所以需要在cookie过期时手动获取并更新cookie值。</p><h1 id="正文">正文</h1><h2id="一快速部署腾讯视频会员自动签到任务">一、快速部署腾讯视频会员自动签到任务</h2><h3 id="登录金山在线文档">1.1 登录金山在线文档</h3><p>进入<ahref="https://www.kdocs.cn/welcome">金山文档首页</a>，点击进入网页版后，选择自己所需要的方式登录金山文档。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821161646487.png"alt="金山文档首页" /><figcaption aria-hidden="true">金山文档首页</figcaption></figure><h3 id="新建一个空白表格并添加一个文档共享脚本">1.2新建一个空白表格并添加一个文档共享脚本</h3><p>①依次选择新建-&gt;表格，创建一个空白表格，右键表格名将表格命名为<code>tencent</code>。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821162040045.png"alt="新建空白表格" /><figcaption aria-hidden="true">新建空白表格</figcaption></figure><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821163449150.png"alt="重命名表格名" /><figcaption aria-hidden="true">重命名表格名</figcaption></figure><p>②创建完成后，鼠标移到表格上方工具栏，依次选择效率-&gt;高级开发-&gt;AirScript脚本编辑器，并选择创建一个文档共享脚本，命名任意。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821163145230.png"alt="创建一个空脚本文件" /><figcaption aria-hidden="true">创建一个空脚本文件</figcaption></figure><p>③将附录<ahref="#完整实现代码">完整实现代码</a>复制粘贴到代码编辑区域</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821171502982.png"alt="复制代码" /><figcaption aria-hidden="true">复制代码</figcaption></figure><p>④点击服务-&gt;添加服务，为脚本添加服务。将云文档API、邮件API、网络API服务都添加。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821171606942.png"alt="为脚本添加服务" /><figcaption aria-hidden="true">为脚本添加服务</figcaption></figure><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821171744466.png"alt="添加三个服务" /><figcaption aria-hidden="true">添加三个服务</figcaption></figure><h3 id="添加表格定时任务来定时运行脚本">1.3添加表格定时任务来定时运行脚本</h3><p>选择效率-&gt;高级开发-&gt;定时任务-&gt;创造任务，添加定时任务，定时任务执行的脚本选择刚刚创建的脚本。</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821171955246.png"alt="创建定时任务" /><figcaption aria-hidden="true">创建定时任务</figcaption></figure><h3 id="配置执行代码任务所需要的参数">1.4配置执行（代码）任务所需要的参数</h3><p>①打开电脑浏览器（这里用的是谷歌，其余浏览器基本大差不差），进入<ahref="https://v.qq.com">腾讯视频官网</a>登录自己的会员账号，右键打开开发者工具栏，切换视图为手机(见<ahref="https://jingyan.baidu.com/article/b907e6278d278f46e7891c8d.html#:~:text=%E6%89%93%E5%BC%80%E9%82%A3%E4%B8%AA%E9%9C%80%E8%A6%81%E5%88%87%E6%8D%A2%E6%88%90%E6%89%8B%E6%9C%BA%E6%A8%A1%E5%BC%8F%E6%98%BE%E7%A4%BA%E7%9A%84%E7%BD%91%E7%AB%99%E3%80%82%204%2F6%20%E6%8C%89%E4%B8%8B%E7%94%B5%E8%84%91%E9%94%AE%E7%9B%98%E4%B8%8A%E7%9A%84%E3%80%90F12%E3%80%91%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%A6%82%E5%9B%BE%E9%A1%B5%E9%9D%A2%E3%80%82,5%2F6%20%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%A6%82%E5%9B%BE%E9%82%A3%E4%B8%AA%E6%89%8B%E6%9C%BA%E7%94%B5%E8%84%91%E5%B1%8F%E5%B9%95%E7%9A%84%E5%9B%BE%E6%A0%87%E3%80%82%20%E6%88%96%E8%80%85%E6%98%AF%E6%8C%89Ctrl%2Bshift%2BM%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E6%88%90%E6%89%8B%E6%9C%BA%E6%A8%A1%E5%BC%8F%E3%80%82">电脑上浏览器如何让网页显示成手机模式？</a>↩︎)，并在浏览器地址框输入<code>https://m.v.qq.com/</code>，刷新网页。</p><p>②从开发者工具栏中找到login_url与login_cookie信息，如图（第一个红圈为切换为手机模式）：</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821174000665.png"alt="开发者工具栏" /><figcaption aria-hidden="true">开发者工具栏</figcaption></figure><p>依次选择NetWork(网络)-&gt;filter(过滤)，输入refre，找到<code>auth_refresh?xxx</code>，点击后右侧栏出现详细信息，点击右侧栏详细信息的Headers(头信息)。然后在头信息中找到login_url与login_cookie，如图：</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821174811339.png"alt="login_url" /><figcaption aria-hidden="true">login_url</figcaption></figure><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821175028781.png"alt="login_cookie" /><figcaption aria-hidden="true">login_cookie</figcaption></figure><p>③将上面所说的login_url与login_cookie的值（值是冒号后面的值）复制到表格中，如图（注意值位置，login_url值在单元格A2，login_cookie值在单元格B2，如需要改变位置需要修改代码）：</p><figure><imgsrc="../img/腾讯视频会员自动签到-基于金山在线文档定时任务/image-20230821175722403.png"alt="配置值" /><figcaption aria-hidden="true">配置值</figcaption></figure><p>⑤邮箱配置为可选，可按照自己的要求配置。若需要发送到自己的邮箱，需要准备一个发送邮箱，一个接收邮箱，并且</p><p>在表格中配置完信息后还需要在代码中配置相关信息，若不需要则在相应表格处填否，且不用在代码中修改值。</p><p>需要修改的代码如下，该代码块位于<ahref="#完整实现代码">完整实现代码</a>的最底部：</p><figure class="highlight javascript"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-a28mx1m18zzwd7"></i><span>JAVASCRIPT</span><div class="collapse show" id="collapse-a28mx1m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 配置发送邮箱，下面以配置QQ邮箱为例子,XXX为需要修改的地方</span><br>  <span class="hljs-keyword">let</span> mailer = <span class="hljs-variable constant_">SMTP</span>.<span class="hljs-title function_">login</span>(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;smtp.qq.com&quot;</span>, <span class="hljs-comment">// 邮箱 的SMTP服务器的域名，此处为QQ</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-number">465</span>, <span class="hljs-comment">//端口号</span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;xxx@qq.com&quot;</span>, <span class="hljs-comment">// 邮箱地址，例如xxx@qq.com</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-comment">// 邮箱的SMTP密码，非密码，获取方式自行百度</span><br>    <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>  mailer.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;腾讯视频签到&lt;mailboy01@qq.com&gt;&quot;</span>, <span class="hljs-comment">// 发件人</span><br>    <span class="hljs-attr">to</span>: email_address, <span class="hljs-comment">// 收件人</span><br>    <span class="hljs-attr">subject</span>: <span class="hljs-string">&quot;腾讯视频签到通知-&quot;</span>+local_date, <span class="hljs-comment">// 主题</span><br>    <span class="hljs-attr">text</span>: execute_result, <span class="hljs-comment">// 文本</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></div></figure><h2 id="二代码实现详解与方法总结">二、代码实现详解与方法总结</h2><h3 id="airscipt中的api">2.1 AirScipt中的API</h3><p>官网写得很清楚<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="AirScipt文档API,[EB/OL],[https://airsheet.wps.cn/docs/api/excel/workbook/overview.html](https://airsheet.wps.cn/docs/api/excel/workbook/overview.html)">[2]</span></a></sup>。注：本文中的功能实现非常基础，几乎未做任何异常处理，望周知。</p><h3 id="方法总结">2.2 方法总结</h3><p>发现没啥好总结的，主要就是抓包，能抓到包什么都好说。可以看出来腾讯视频会员签到的接口是没有那种每次都动态加密的，也就是每次请求都要携带一串不同的“密文”（点名批评某B，爬不了一点），所以用Cookie很容易就解决了验证问题。</p><h1 id="附录">附录</h1><h3 id="完整实现代码">完整实现代码</h3><p>注意：代码中除了邮件中的参数必须自己配置外，其余参数都是配置要求都是可选的，或者是在表格文件中完成配置的（因为写死在代码中修改太麻烦了）。</p><figure class="highlight javascript"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-uovh5pm18zzwd7"></i><span>JAVASCRIPT</span><div class="collapse show" id="collapse-uovh5pm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//选中特定sheet(表单)</span><br><span class="hljs-keyword">var</span> sheets = <span class="hljs-title class_">Application</span>.<span class="hljs-property">Sheets</span>;<br><span class="hljs-keyword">var</span> sheet;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= sheets.<span class="hljs-property">Count</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>((sheets.<span class="hljs-title class_">Item</span>(i).<span class="hljs-property">Name</span>)===<span class="hljs-string">&quot;tencent&quot;</span>)&#123;<br>      sheet = sheets.<span class="hljs-title class_">Item</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//获取当前日期</span><br><span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">var</span> local_date = myDate.<span class="hljs-title function_">toLocaleDateString</span>();<br><span class="hljs-comment">//获取邮件信息</span><br><span class="hljs-keyword">var</span> email_address = sheet.<span class="hljs-title class_">Range</span>(<span class="hljs-string">&quot;B9&quot;</span>).<span class="hljs-property">Text</span>;<br><span class="hljs-keyword">var</span> email_send_bool = sheet.<span class="hljs-title class_">Range</span>(<span class="hljs-string">&quot;B8&quot;</span>).<span class="hljs-property">Text</span>;<br><span class="hljs-comment">//初始化任务执行参数</span><br><span class="hljs-keyword">var</span> login_url_data = sheet.<span class="hljs-title class_">Range</span>(<span class="hljs-string">&quot;A2&quot;</span>).<span class="hljs-property">Text</span>;<br><span class="hljs-keyword">var</span> login_cookie_data = sheet.<span class="hljs-title class_">Range</span>(<span class="hljs-string">&quot;B2&quot;</span>).<span class="hljs-property">Text</span>;<br><span class="hljs-comment">//初始化执行结果</span><br><span class="hljs-keyword">var</span> execute_result = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">//执行任务</span><br>execute_result = <span class="hljs-title function_">tencent_video_sign_in</span>();<br><span class="hljs-comment">//确认是否发送邮件</span><br><span class="hljs-keyword">if</span>(email_send_bool==<span class="hljs-string">&quot;是&quot;</span>)&#123;<br>  <span class="hljs-title function_">send_email</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(execute_result);<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tencent_video_sign_in</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//刷新登录状态的url</span><br>  <span class="hljs-keyword">let</span> login_url = <span class="hljs-string">&quot;https://access.video.qq.com/user/auth_refresh?vappid=xxx&amp;vsecret=xxx&amp;type=qq&amp;g_tk=&amp;g_vstk=xxx&amp;g_actk=xxx&quot;</span>;<span class="hljs-comment">//login_url的格式说明</span><br>  <span class="hljs-keyword">let</span> login_cookie = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><br>  login_url = login_url_data;<br>  login_cookie = login_cookie_data;<br><br>  <span class="hljs-keyword">let</span> auth_cookie = <span class="hljs-string">&#x27;app_ver=8.8.10.25828;call_type=1;isDarkMode=1;deviceModel=Unknown iPad;systemVersion=16.2;main_login=qq;vdevice_qimei36=d4641bb8597a7ebaa497cbd900001c916614;&#x27;</span>;<span class="hljs-comment">//这个值是网上的其他博主提供的，也可以自己抓包手机端的数据，获取自己的值，但是很麻烦，所以这里直接给出现成的值</span><br><br>  <span class="hljs-comment">//获取签到需要的cookie</span><br>  <span class="hljs-keyword">let</span> login_resp = <span class="hljs-variable constant_">HTTP</span>.<span class="hljs-title function_">get</span>(<br>    login_url,&#123;<br>      <span class="hljs-attr">headers</span>:&#123;<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://v.qq.com&#x27;</span>,<br>        <span class="hljs-string">&#x27;Cookie&#x27;</span>: login_cookie<br>      &#125;<br>    &#125;<br>  );<br>  <br><br>  <span class="hljs-keyword">if</span>(login_resp.<span class="hljs-property">status</span>===<span class="hljs-number">200</span>)&#123;<br>    <span class="hljs-comment">//拼装auth_cookie</span><br>    <span class="hljs-keyword">let</span> cookiesArr_in_resp = login_resp.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;set-cookie&#x27;</span>];<span class="hljs-comment">//wps给的api不能直接获取cookie，所以从header中获取</span><br>    <span class="hljs-keyword">let</span> cookie_json_str = <span class="hljs-string">&quot;&#123;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>;count&lt;cookiesArr_in_resp.<span class="hljs-property">length</span>;count++)&#123;<br>      cookie_json_str = cookie_json_str + <span class="hljs-string">&quot;\&quot;&quot;</span> +cookiesArr_in_resp[count].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;;&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;=&quot;</span>,<span class="hljs-string">&quot;\&quot;:\&quot;&quot;</span>) + <span class="hljs-string">&quot;\&quot;&quot;</span>;<span class="hljs-comment">//第零个为cookie名+cookie值</span><br>      <span class="hljs-keyword">if</span>(count+<span class="hljs-number">1</span>&lt;cookiesArr_in_resp.<span class="hljs-property">length</span>)&#123;<br>        cookie_json_str = cookie_json_str + <span class="hljs-string">&quot;,&quot;</span>;<br>      &#125;<br>    &#125;<br>    cookie_json_str = cookie_json_str+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    <span class="hljs-keyword">let</span> cookie_json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(cookie_json_str);<br>    auth_cookie = auth_cookie+<span class="hljs-string">&#x27;vqq_vusession=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_vusession&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span>+<span class="hljs-string">&#x27;vqq_access_token=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_access_token&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span>+<span class="hljs-string">&#x27;vqq_appid=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_appid&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span>+<span class="hljs-string">&#x27;vqq_openid=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_openid&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span>+<span class="hljs-string">&#x27;vqq_refresh_token=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_refresh_token&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span>+<span class="hljs-string">&#x27;vqq_vuserid=&#x27;</span>+cookie_json[<span class="hljs-string">&#x27;vqq_vuserid&#x27;</span>]+<span class="hljs-string">&#x27;;&#x27;</span><br>    <span class="hljs-comment">//签到</span><br>    <span class="hljs-keyword">let</span> sign_in_url = <span class="hljs-string">&quot;https://vip.video.qq.com/rpc/trpc.new_task_system.task_system.TaskSystem/CheckIn?rpc_data=&#123;&#125;&quot;</span><br>    <span class="hljs-keyword">let</span> referer = <span class="hljs-string">&#x27;https://film.video.qq.com/x/grade/?ovscroll=0&amp;ptag=Vgrade.card&amp;source=page_id=default&amp;ztid=default&amp;pgid=page_personal_center&amp;page_type=personal&amp;is_interactive_flag=1&amp;pg_clck_flag=1&amp;styletype=201&amp;mod_id=sp_mycntr_vip&amp;sectiontype=2&amp;business=hollywood&amp;layouttype=1000&amp;section_idx=0&amp;mod_title=会员资产&amp;blocktype=6001&amp;vip_id=userCenter_viplevel_entry&amp;mod_idx=11&amp;item_idx=4&amp;eid=button_mycntr&amp;action_pos=jump&amp;hidetitlebar=1&amp;isFromJump=1&amp;isDarkMode=1&amp;uiType=HUGE&#x27;</span>;<br>    referer = <span class="hljs-built_in">encodeURI</span>(referer);<br>    <span class="hljs-keyword">let</span> sign_resp = <span class="hljs-variable constant_">HTTP</span>.<span class="hljs-title function_">get</span>(<br>      sign_in_url,&#123;<br>        <span class="hljs-attr">headers</span>:&#123;<br>          <span class="hljs-string">&#x27;Referer&#x27;</span>: referer,<br>          <span class="hljs-string">&#x27;Host&#x27;</span>: <span class="hljs-string">&#x27;vip.video.qq.com&#x27;</span>,<br>          <span class="hljs-string">&#x27;Origin&#x27;</span>: <span class="hljs-string">&#x27;https://film.video.qq.com&#x27;</span>,<br>          <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (iPad; CPU OS 16_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/11A465 QQLiveBrowser/8.8.10 AppType/HD WebKitCore/WKWebView iOS GDTTangramMobSDK/4.370.6 GDTMobSDK/4.370.6 cellPhone/Unknown iPad AppBuild/25828&#x27;</span>,<br>          <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate, br&#x27;</span>,<br>          <span class="hljs-string">&quot;Cookie&quot;</span>: auth_cookie<br>        &#125;<br>      &#125;<br>    );<br>    <span class="hljs-comment">//检查签到结果并做出相应处理</span><br>    <span class="hljs-keyword">let</span> sign_result_json = sign_resp.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">if</span>(sign_result_json[<span class="hljs-string">&#x27;ret&#x27;</span>]!=<span class="hljs-number">0</span>)&#123;<br>      execute_result = execute_result + <span class="hljs-string">&quot;签到失败，错误信息：&quot;</span>+sign_result_json[<span class="hljs-string">&#x27;err_msg&#x27;</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      execute_result = execute_result + <span class="hljs-string">&quot;签到成功，签到积分：&quot;</span>+sign_result_json[<span class="hljs-string">&#x27;check_in_score&#x27;</span>];<br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    execute_result = execute_result + <span class="hljs-string">&quot;签到请求异常.&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> execute_result;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 配置发送邮箱，下面以配置QQ邮箱为例子</span><br>  <span class="hljs-keyword">let</span> mailer = <span class="hljs-variable constant_">SMTP</span>.<span class="hljs-title function_">login</span>(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;smtp.qq.com&quot;</span>, <span class="hljs-comment">// 邮箱 的SMTP服务器的域名</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-number">465</span>,<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;xxx@qq.com&quot;</span>, <span class="hljs-comment">// 邮箱地址，例如xxx@qq.com</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-comment">// 邮箱的SMTP密码，非密码</span><br>    <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>  mailer.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;腾讯视频签到&lt;mailboy01@qq.com&gt;&quot;</span>, <span class="hljs-comment">// 发件人</span><br>    <span class="hljs-attr">to</span>: email_address, <span class="hljs-comment">// 收件人</span><br>    <span class="hljs-attr">subject</span>: <span class="hljs-string">&quot;腾讯视频签到通知-&quot;</span>+local_date, <span class="hljs-comment">// 主题</span><br>    <span class="hljs-attr">text</span>: execute_result, <span class="hljs-comment">// 文本</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></div></figure><h1 id="参考资料">参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>腾讯视频云签到,[EB/OL](2023-06-04),<ahref="https://blog.csdn.net/lvhaoye/article/details/119963357">https://blog.csdn.net/lvhaoye/article/details/119963357</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>AirScipt文档API,[EB/OL],<ahref="https://airsheet.wps.cn/docs/api/excel/workbook/overview.html">https://airsheet.wps.cn/docs/api/excel/workbook/overview.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>自动化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>自动化</tag>
      
      <tag>金山在线文档</tag>
      
      <tag>腾讯视频会员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语写作练习002</title>
    <link href="/article/bc45282.html"/>
    <url>/article/bc45282.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>未完成文章</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>本分类旨在练习本人英文写作水平，结构一般为<code>原文</code>、<code>修改文</code>组成，内容一般为日记形式的任意内容，注意修改的方法参考的是GPT的答案。</p><h1 id="正文">正文</h1><h2 id="原文">原文</h2><p><strong>Friday,August 11st,2023,Sunny</strong></p><p>Opened the calendar on the wall,"August 8th" is sticked on it, makingme anxious like the past everytime.I'm so tired,so weak,and sofrustrated.</p><p>What I most thirsty for now is "REGULAR",which could give me thechance to success,but I just could't do it.It's so hard for lonelyme.Every night,the soft pillow like a gift for my solitary soul,I'm justfeeling so fucking hard in this period time.</p><p>Tonight I went out,and ran along with the housing estate's edge."300meters,500 meters...",watching the distance I ran away,with theheartbeat number increasing 197 per second,I felt my head becoming moreand more heavy,and so much sweater on my eyes.I stopped finally, makingevery endeavor to pant for more air.Although my body was so heavy,mymood likely became so light.</p><h2 id="修改文">修改文</h2><h3 id="最终修改结果">最终修改结果</h3>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>英语写作</tag>
      
      <tag>日记</tag>
      
      <tag>练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语作文练习001</title>
    <link href="/article/443ff889.html"/>
    <url>/article/443ff889.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>本分类旨在练习本人英文写作水平，结构一般为<code>原文</code>、<code>修改文</code>组成，内容一般为日记形式的任意内容，注意修改的方法参考的是GPT的答案。</p><h1 id="正文">正文</h1><h2 id="原文">原文</h2><p><strong>Wednesday,August 9th,2023,Rainy</strong></p><p>Today,I start to have a try for practicing my English writing skillfinally. To be honest, I'm indeed worried about the status that I havenot even finished the basic learning which should be done before thismonth, but I just finish the half.</p><p>Hope I can hold on my mind,and keep on going.</p><p>That's all, the first of my diary for my thinking. Hoping it will notbe bullshit,I mean the grammar.</p><h2 id="修改文">修改文</h2><h3 id="最终修改结果">最终修改结果</h3><p><strong>Wednesday,August 9th,2023,Rainy</strong></p><p>Today,I <u>finally started to give it a shot</u> at practicing myEnglish writing skill. To be honest,I'm indeed a<u>nxious about</u> thefact that I have not <u>completed the fundamental lessons</u> whichshould be done before this month,but I <u>have only finished the half ofit</u>.</p><p>Hope I can <u>stay focused</u> and keep going.</p><p>That's all for the first of my diary for my thinking. Hoping it won'tbe <u>nonsense</u>,I mean <u>in terms of</u> grammar.</p><h3 id="日期">1.日期</h3><div class="note note-info">            <p><strong><code>Wednesday,August 9th,2023,Rainy</code></strong></p>          </div><p>没毛病</p><h3 id="第一段">2.第一段</h3><div class="note note-info">            <p>Today,I start to have a try for practicing my English writing skillfinally.</p>          </div><p><strong>首先，语法上：</strong></p><p>①<code>start to</code>动词时态错误，应该是过去式，改为<code>started to</code>。在以下情况会用到一般现在时（注：并不全面）：</p><ul><li>表示经常的或习惯性的动作，常与表示频度的时间状语连用。</li><li>表示主语具备的性格、能力和特征。</li><li>表示现在的状态。</li><li>表示客观事实和普遍真理。</li><li>有些表示状态和感觉的动词表示现在发生的具体行为时，只用一般现在时，而不用进行时态。</li><li>表示现在发生的具体动作或存在的状态</li></ul><p><strong>其次，内容表达上：</strong></p><p>①<code>have a try</code>是小学僧语法，建议改为<code>attempt to</code>或者<code>give a shot</code>。</p><p>②<code>finally</code>放在后面有点语句不同，可以直接放在最前面，即：<code>I finally started to...</code></p><p><strong>最终修改为：</strong><code>Today,I finaly started to give it a shot at practicing my English writing skill.</code></p><div class="note note-info">            <p>To be honest, I'm indeed worried about the status that I have noteven finished the basic learning which should be done before this month,but I just finish the half.</p>          </div><p><strong>首先，语法上：</strong></p><p>①<code>I'm</code>这里后面表示的是一种状态，所以可以用一般现在时，但是<code>but I jsut finish</code>明显错了，改成<code>finished</code>，但是为了一致都用一般现在完成式<code>have finsihed</code>。</p><p><strong>其次，内容表达上：</strong></p><p>①<code>be worried about</code>小学僧语法，可以替代为<code>be anxious about</code>增强情感，或者使用<code>be concerned about</code>表示偏理性地担忧。</p><p>②<code>the status</code>感觉有点不顺口，表达的是状态、地位，可以改为<code>fact</code>，表示描述已经发生的事实，<code>even</code>也有点不顺口，删掉。</p><p>③<code>basic</code>小学僧表达，改用<code>fundamental</code>或者<code>essential</code>，<code>finish</code>小学僧表达，可以改用<code>complete</code>，感觉还是小学僧表达啊？</p><p>④<code>before</code>用法是没问题的且准确的，这里我想要表达的是在这个月之前就要完成，如果使用<code>by</code>意思就变成了在这个月结束之前完成，意思就不对了。</p><p><strong>最终修改为：</strong><code>To be honest,I'm indeed anxious about the fact that I have not completed the fundamental lessons which should be done before this month,but I have only finished the half of it.</code></p><h3 id="第二段">3.第二段</h3><div class="note note-info">            <p>Hope I can hold on my mind,and keep on going.</p>          </div><p><strong>首先，语法方面，</strong>没有毛病；<strong>但是内容表达方面</strong>，<code>hold on my mind</code>属于拉稀英语词组，表达非常不流畅且属于自创词组，可以改为<code>stay focused</code>或者<code>remain determined</code>，同时句子太短没必要分个逗号。</p><p><strong>最终修改为：</strong><code>Hope I can stay focused and keep going.</code></p><h3 id="第三段">4.第三段</h3><div class="note note-info">            <p>That's all, the first of my diary for my thinking. Hoping it will notbe bullshit,I mean the grammar.</p>          </div><p><strong>首先，语法方面，</strong>没有问题；但是<strong>内容表达上，</strong><code>bullshit</code>为俚语，主要是过于粗俗，建议替代为<code>nonsense</code>或者<code>rubbish</code>，表示胡说八道，然后就是当使用感叹句来表达希望时，通常不会使用否定词<code>not</code>，即连起来使用<code>won't</code>（？GPT这么说的，我也不知道啥意思），最后<code>I mean the grammar</code>意义表达不通顺，改为<code>I mean in terms of grammar</code>，interms of 意为：就...而言。</p><p><strong>最终改为：</strong><code>That's all for the first of my diary for my thinking.Hoping it won't be nonsense,I mean in terms of grammar.</code></p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>英语写作</tag>
      
      <tag>日记</tag>
      
      <tag>练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android中控件实际呈现宽高与Java中动态设置的宽高不一致</title>
    <link href="/article/d0bab982.html"/>
    <url>/article/d0bab982.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>今天在写安卓的时候，需要用java代码去动态的改变一个按钮的宽高，但是意外地发现实际呈现出来的宽高只有高是被设置成功的，而按钮的宽度总是比想设置的宽一些，找了好一会儿才发现了问题所在，在这里记录一下这个问题。</p><h1 id="正文">正文</h1><h2 id="一快速解决方案">一、快速解决方案</h2><p>删除xml文件中对应控件的weight属性（如果有的话）。若还不生效，删除对应控件中所有宽高相关的的属性设置。</p><h2 id="二详细问题分析">二、详细问题分析</h2><h3 id="环境还原">1、环境还原</h3><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-toexn8m18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-toexn8m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImgBtnLayoutParams</span><span class="hljs-params">(ImageButton imageButton,<span class="hljs-type">int</span> widthPX,<span class="hljs-type">int</span> heightPX)</span>&#123;<span class="hljs-comment">//设置imgBtn的布局</span><br>    ViewGroup.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">layoutParams</span> <span class="hljs-operator">=</span> imageButton.getLayoutParams();<span class="hljs-comment">//获取imgBtn的默认布局</span><br>    layoutParams.height = heightPX;<span class="hljs-comment">//设置高，单位为像素</span><br>    layoutParams.width = widthPX;<span class="hljs-comment">//设置宽，单位为像素</span><br>    imageButton.setLayoutParams(layoutParams);<span class="hljs-comment">//更新imgBtn的布局</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>这是实现功能的关键代码，主要功能是改变按钮的宽高。这里<code>imageButton</code>是需要被改变宽、高的控件，<code>widthPX</code>、<code>heightPX</code>分别为需要设置宽高。使用的是普通的方法，按道理说不会有什么问题，但是很不幸的是还是出了问题——按钮宽度总是比设置的宽度长一点。</p><h3 id="问题分析">2、问题分析</h3><p>log一下按钮动态改变前、动态改变后的宽度，居然发现总是有<code>改变后的宽度值=想要改变的宽度值+一个未知值71</code>，好家伙，这是直接相加了。</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-xaq56rm18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-xaq56rm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">before: width of set is 90PX<br>after: width of reality is 161PX<br></code></pre></td></tr></table></div></figure><p>那么这个未知值71是怎么来的？除了java代码里，那肯定是从XML文件中的属性里来的，如下为对应XML属性：</p><figure class="highlight xml"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wia9epm18zzwd7"></i><span>XML</span><div class="collapse show" id="collapse-wia9epm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/back_btn&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/baseline_arrow_back_02&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:contentDescription</span>=<span class="hljs-string">&quot;@string/des_back_icon&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ImageButton</span>&gt;</span><br></code></pre></td></tr></table></div></figure><p>可以看到，在XML中会直接影响width只有<code>android:layout_width="0dp"</code>与<code>android:layout_weight="1"</code>，而<code>layout_width</code>属性肯定是没问题的（因为java代码中设置的就是这个值），只有可能是<code>lauout_weight</code>属性（注：这里的weight实际将控件宽度设置为了相对于总宽度的1/12，且还有一个属性与该控件相同布局的按钮）。有了这个思路，再将java代码部分删除（不动态设置）后，再log一下按钮动态改变前、动态改变后的宽度：</p><figure class="highlight java"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-hq6py4m18zzwd7"></i><span>JAVA</span><div class="collapse show" id="collapse-hq6py4m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">before: width of set is 90PX<br>after: width of reality is 86PX<br></code></pre></td></tr></table></div></figure><p>现在试着将86与71联系起来。前面说了，weight实际将控件宽度设置为了相对于总宽度的1/12，那么总宽度为<code>86*12=1032</code>，随后因为有一个和该控件相同布局的按钮，则<code>1032-90*2=852</code>，<code>852/12=71</code>，这不巧了吗。</p><p><strong>所以，结论是：当weight属性存在时，若对应宽度或高度值（统称为长度）不为零，则weight值的计算会在总长度减去设置的长度后再按比例设置，且控件的最终长度为<code>weight计算的值+设置的长度值</code>。</strong></p><h3 id="解决方法">3、解决方法</h3><p>取消weight属性即可。当然，由此类推，若没有weight属性仍然出现了相关问题，则一定是存在某个会直接影响长度的属性值，删除它即可。</p>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>前端综合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Android</tag>
      
      <tag>java</tag>
      
      <tag>设置控件宽高</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幼儿趣味智力题-001-忙碌的厨房</title>
    <link href="/article/7c0c2f3.html"/>
    <url>/article/7c0c2f3.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>本系列文章位于语文-&gt;小说分类下，所以目的其实就是为写小说积累素材。</p><p>本系列文章内容是基于博主在平时遇到的有意思的生活现象上，延伸思考的一些思维训练题，所有思维题都会尽量贴近生活同时有趣味性，所有题目思维出发点均适用于幼儿教育，但是题目描述需要自行进行幼儿化处理。</p><p>文章内容将由题目、题解两部分组成，题解仅供参考。</p><h1 id="正文">正文</h1><h2 id="忙碌的厨房">忙碌的厨房</h2><p>小明家的厨房灶台有两个灶眼，即可以同时放两个锅来烧菜煮饭。同时，小明家厨房里还有三口锅和多个大大小小的碗与其他盛器。</p><p>有一天晚上小明独自在家煮白水面条吃，于是他把一口锅放在一个灶眼上倒上水就直接生火了。水烧了一会，小明接到消息自己的朋友要来自己家玩，且他朋友也没有吃晚饭，于是小明决定换煮鸡蛋面。小明煮鸡蛋面的方法为：先炒一个鸡蛋，将鸡蛋单独盛出来放在碗里，再往炒鸡蛋的锅里直接加水用来煮面条，这样烧的水会有一点鸡蛋的香气。但是现在水已经在一口锅里烧了一段时间了，现在小明该怎样做才能最方便地煮好这锅鸡蛋面？</p><h2 id="参考答案点击显示">参考答案(点击显示)</h2><p><span id="after_click_out_div"onclick="javascript:this.setAttribute(&#39;style&#39;, &#39;background-image: none;color: rgba(0,0,0,1);&#39;)">想了一会儿，小明决定先在另外一个灶眼里炒好鸡蛋，盛放在碗里，然后直接将另外一口锅里烧好的水直接倒到炒完鸡蛋的锅里，最后在炒鸡蛋的锅里煮面条，而另外一口锅也没弄脏，不用洗了，小明心里美滋滋😋</span></p>]]></content>
    
    
    <categories>
      
      <category>语文</category>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>幼儿教育</tag>
      
      <tag>思维训练</tag>
      
      <tag>脑筋慢转弯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虎牙自动送每日礼物(虎粮)</title>
    <link href="/article/b916b90f.html"/>
    <url>/article/b916b90f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章未完成。难产了家人们，发现根本抓不了包。</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>许久没有登录虎牙，今日偶然打开虎牙看了看——诶，怎么消息框还有几个未读消息？赶紧点进去一看，结果全是“您与XXX的徽章亲密度正在下降”，啥也不是😅。</p><p>自从这虎牙改版后，只要隔几天不去送礼物来增加亲密度，自己那粉丝徽章就熄灭了，然后好不容易累积起来的亲密度也开始光速下降，可是正常人谁没事天天特意去某个直播间去送礼物维持亲密度不掉啊，隔这打卡上班呢，但是又心疼自己好不容易得来的N级粉丝徽章，所以准备做个简单的私人自动化小工具（也就是网络爬虫），让它帮我每天去虎牙“上班打卡”吧。</p><p>本爬虫基于java实现，使用cookie完成身份验证，仅支持个人轻量级使用。</p><h1 id="正文">正文</h1><h2 id="一需求确定">一、需求确定</h2><p>做一件事，那肯定首先得明白自己到底要干什么、目的是什么，所以本章先浅浅说明这些问题。</p><p><strong>业务方面</strong>：每天帮我自动登录虎牙账号，并找到有徽章的主播，将自己的每日免费虎粮分别送给这些主播；<strong>性能方面</strong>：仅作为私人使用，不需要大批量处理事务；<strong>安全方面</strong>：尽可能地安全，不在代码中太多任何隐私相关静态数据，不建立数据库静态存储隐私信息。</p><p>以上就是所有要求了，所有接上来按照这些要求来开发一个简单的小玩意儿。</p><h2 id="二技术路线选择">二、技术路线选择</h2><p>选择技术路线时，需要根据具体的需求来选择对应的技术，也就是一切都是建立在解决需求之上的，至于技术什么的除非是要学习，否则管他个鸟。</p><p>从上一章的内容再结合实际，可以得出需要解决的主要需求有：<strong>①开发语言的选择</strong>：我主要会java，那就选java；<strong>②抓包工具的选择</strong>：我主要用Fiddler，那就用Fidller；<strong>③爬虫登录账号时的身份验证方式</strong>：一般来说，为了安全性，在登录时会遇到网站的百般阻挠，例如要求输入验证或者滑动验证甚至点击验证，同时加上前端的加密传输方式，这都不是这么容易破解的，对我来说显然会耗费大量的时间才容易找到适配的解决方法。由于需求不大，只针对个人使用，所以就选择最最最最简单的方式——cookie验证，耶，不到三十秒解决了最难的问题！；<strong>④免费虎粮在赠送给多个主播的分配策略</strong>：在有虎粮的前提下，默认按照徽章等级占比来分配虎粮，当然也支持用户在参数里自定义虎粮分配；<strong>⑤默认参数设置</strong>：为安全性，默认参数均采用动态输入，即在代码运行时输进去，不采用静态保存数据，应用进程销毁，则数据销毁。</p><h2 id="三开始开发">三、开始开发</h2><div class="note note-warning">            <p>突然发现根本抓不了送虎粮接口的包，百度谷歌Github了一圈，也只有基于selenium之类的，这种对环境的要求实在是太高了，实现起来不现实，而抓包接口的帖子只有一个，结果点进去一看，说自己抓不了。</p><p>这个问题留在这里，以后牛逼了再回来解决。</p>          </div><h3 id="登录必要cookie确定">1.登录必要cookie确定</h3><p>采用最质朴的方法，浏览器里面打开本地cookie，然后一个一个删除，再刷新页面，查看是否能保持登录状态。如果删除一个cookie后不能保持登录状态，则证明该cookie为必要cookie。</p><p>(将那些除带有token、credit、uid之类的变量之外的cookie名删除，然后再经过一系列操作验证)最后得到，必要cookie有：</p><table><thead><tr class="header"><th>Cookie名</th><th>Domain</th><th>有效持续时间</th></tr></thead><tbody><tr class="odd"><td>udb_biztoken</td><td>.huya.com</td><td>15天</td></tr><tr class="even"><td>yyuid</td><td>.huya.com</td><td>15天</td></tr><tr class="odd"><td>udb_cred</td><td>.huya.com</td><td></td></tr></tbody></table><h3 id="查询徽章列表">2.查询徽章列表</h3><h3 id="查询虎粮数量">3.查询虎粮数量</h3><h3 id="赠送特定虎粮给特定主播">4.赠送特定虎粮给特定主播</h3><h1 id="参考文献">参考文献</h1><h1 id="附录">附录</h1>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>自动化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>待完成</tag>
      
      <tag>自动化</tag>
      
      <tag>虎牙直播</tag>
      
      <tag>直播礼物</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Gitee上免费搭建个人博客（GITEE+HEXO+FLUID）</title>
    <link href="/article/12edf58a.html"/>
    <url>/article/12edf58a.html</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章未完成</p>          </div><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>搭建一个个人博客网站相信是许多编程（特别是web编程）初学者都想过且十分想实现的一个目标，因为能够在网络上将自己经验心得分享给全世界本身就是一件很酷的事，就像微信朋友圈一样，不过这个不同的就是有可能在这个“朋友圈”里你发一个博客可能几年都不会有人看见，直接就石沉大海了[狗头]，但是贵在这个朋友圈个人定制性更强，想怎么炫酷就怎么炫酷😎，不是吗[狗头]。问题来了，怎么去搭建呢？肯定第一步得整个服务器呗，三种方式：</p><ul><li>个人屋里整个服务器【富哥可以考虑考虑】</li><li>网上购买云服务器【阿里云举例，一般新用户100一年，可以99连续续杯两年】</li><li>使用第三方的免费云空间【白嫖多是一件美事啊】</li></ul><p>没错，接下来有请我们的主角：Giteepages登场！本文主要是帮助小白学会如何利用Giteepages搭建一个免费的个人博客网站，同时会推荐Hexo+Fluid博客模板的安装，并给出一些Giteepages使用细节提醒。<strong>注意，在阅读此文章之前你需要掌握以下要求的知识或技能：</strong></p><ol type="1"><li>稍微了解html、css、js前端基础三件套，即差不多知道是个什么东西就行，能敲上几行更好【预计花费10分钟】</li><li>大概了解Git是什么，以及本地电脑已经安装了Git，并能够在本地简单使用Git操作，<ahref="https://zhuanlan.zhihu.com/p/99313784">点击此处前往了解</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="杨根杰，Git是什么？可以用来做什么？如何使用？[EB/OL]，[https://zhuanlan.zhihu.com/p/99313784](https://zhuanlan.zhihu.com/p/99313784)，2019-12-25">[1]</span></a></sup>【预计花费30分钟】</li><li>大概了解<ahref="https://gitee.com/help/articles/4105">Gitee是什么</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Gitee，Gitee帮助中心[EB/OL]，[https://gitee.com/help/articles/4105](https://gitee.com/help/articles/4105)">[2]</span></a></sup>以及<ahref="https://blog.csdn.net/ios_xumin/article/details/118361335">Git与Gitee两者之间的关系</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="有没有人告诉你，git、gitee、github、gitlab 区别以及功能[EB/OL]，[https://blog.csdn.net/ios_xumin/article/details/118361335](https://blog.csdn.net/ios_xumin/article/details/118361335)，2021-06-30">[3]</span></a></sup>【大概花费10分钟】</li><li><span style="color:grey">(可选项)了解Markdown语法，<ahref="https://zhuanlan.zhihu.com/p/136440613">点击此处了解</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="码农充电站，如何使用Markdown 编写文档[EB/OL]，[https://zhuanlan.zhihu.com/p/136440613](https://zhuanlan.zhihu.com/p/136440613)，2020-04-26">[4]</span></a></sup>【大概花费10分钟】</span></li></ol><div class="note note-warning">            <p>本教程适用于Windows系统</p>          </div><h1 id="正文">正文</h1><h2 id="一gitee-pages简介">一、Gitee pages简介</h2><p>前面如果已经了解过Gitee是什么后，应该就知道可以使用Gitee创建一个仓库，这个仓库(500M空间)就像相当于Gitee给你的一个云盘，只不过这个云盘支持Git服务，<code>Gitee pages</code>服务就是建立在Gitee仓库上的扩展服务。</p><p>先看官方给的说明：<code>Gitee Pages</code>是一个免费的静态网页托管服务，可以使用 <code>Gitee Pages</code>托管博客、项目官网等静态网页（和 <code>Github Pages</code> 类似）。目前<code>Gitee Pages</code> 支持Jekyll、Hugo、Hexo编译静态资源。【简单来说就是把你的仓库当成静态网页解析，如果有个index.html在仓库一级目录里，直接就可以解析为一个网页展示出来】</p><p>关键词：免费、静态网页托管，虽然只能托管<code>静态网页</code>，但是对于博客来说正好合适，并且可以通过一些现成的项目工具使其动起来（一丢丢），Giteepages博客示例：<a href="https://putik-666.gitee.io/">putik的博客</a></p><h2id="二开始搭建一个简单的个人博客页面">二、开始搭建一个简单的个人博客页面</h2><h3 id="注册gitee-pages账号">2.1 注册Gitee pages账号</h3><p>如果要使用Gitee pages服务首先得注册一个Gitee pages账号，<ahref="https://gitee.com/">点此前往注册：https://gitee.com/</a></p><h3 id="创建代码仓库并开启gitee-pages服务">2.2 创建代码仓库并开启Giteepages服务</h3><p>①注册完账号，登录并进入个人首页，按如图进入创建代码仓库页面</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428133306963.png"alt="进入创建仓库页面" /><figcaption aria-hidden="true">进入创建仓库页面</figcaption></figure><p>②填写仓库必要信息，仓库名称与路径均为必填项（如何填见③）</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428135205887.png"alt="设置仓库信息" /><figcaption aria-hidden="true">设置仓库信息</figcaption></figure><p>③填写完仓库信息后，点击<code>创建</code>完成仓库创建</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428135341714.png"alt="完成创建" /><figcaption aria-hidden="true">完成创建</figcaption></figure><p>④创建后会自动进入仓库页面</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428142608226.png"alt="了解仓库页面" /><figcaption aria-hidden="true">了解仓库页面</figcaption></figure><p>⑤开启Gitee pages服务</p><p>在仓库页面前往：服务--&gt;Gitee pages，到达Giteepages服务页面，如图，<code>部署分支</code>默认即可，<code>部署目录</code>部分不用填，然后<code>强制使用HTTPS</code>可选可不选，然后选择开启即可：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428165121255.png"alt="开启pages服务" /><figcaption aria-hidden="true">开启pages服务</figcaption></figure><p>部署成功后会出现如图一个<code>更新</code>按钮，每次点击<code>更新</code>按钮时，会重新解析你的仓库代码，更新<code>Gitee pages</code>服务为该仓库生成的对应的静态页面(在下面就统称你的<code>博客页面</code>，<spanstyle="color:red">博客页面地址就是篮圈里面的那个地址</span>)。【注意：即时每次你的仓库代码更新了，但是博客页面并不会自动更新，需要你去服务页面手动更新】【再注：即你的博客页面内容虽然与你的代码内容是对应的，但是你的代码更新了，你的博客页面并不会自动更新，得手动去更新】</p><h3 id="生成一个简单的个人博客页面">2.3 生成一个简单的个人博客页面</h3><p>点击<code>&lt;/&gt;代码</code>回到仓库代码页首页，点击初始化readme文件，正式将仓库初始化为一个支持Git服务的文件夹，初始化成功后仓库代码页变为如下页面：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428170619669.png"alt="开始新建一个网络静态页面" /><figcaption aria-hidden="true">开始新建一个网络静态页面</figcaption></figure><p>可以看到多了许多东西，但主要是多了一行操作栏，选择文件--&gt;新建文件，开始创建一个index.html文件(代码见下示例)：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428172418969.png"alt="编写页面内容" /><figcaption aria-hidden="true">编写页面内容</figcaption></figure><p>按如图把文件写好，并写好代码后，直接点击<code>提交</code>即可，代码示例：</p><figure class="highlight html"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-pxddybm18zzwd7"></i><span>HTML</span><div class="collapse show" id="collapse-pxddybm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>putik-663的博客<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;哈喽沃德！&quot;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>        哈喽沃德<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></div></figure><p>提交成功后再点击<code>&lt;/&gt;代码</code>回到仓库代码页首页，可以看到已经多了一个index.html文件：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428173427699.png"alt="查看创建结果" /><figcaption aria-hidden="true">查看创建结果</figcaption></figure><p>此时再前往Giteepages服务页面点击<code>更新</code>按钮，等待完成更新后，直接访问博客地址，出现<code>哈喽沃德</code>即成功部署一个最简答的静态网页。</p><h3 id="通过本地git更新gitee仓库">2.4 通过本地Git更新Gitee仓库</h3><p>首先确保你已经安装了Git（<ahref="https://zhuanlan.zhihu.com/p/99313784">Git介绍、安装与是使用教程</a>），任意新建一个文件夹，进入文件夹进行Git初始化，若未设置用户名与邮箱使用以下命令设置：</p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-9bojyim18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-9bojyim18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git config --list 可以查看是否创建成功</span><br>$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br><span class="hljs-comment"># 把Your Name改成你的昵称；</span><br><span class="hljs-comment"># 把email@example.com改成邮箱的格式，只要格式正确即可。</span><br></code></pre></td></tr></table></div></figure><h4 id="git生成ssh公钥注意替换邮箱"><strong>2.4.1Git生成SSH公钥(注意替换邮箱)</strong></h4><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-vyttf1m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-vyttf1m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C *xxx@xx.com*<br></code></pre></td></tr></table></div></figure><p>执行命令后按提示输入文件名、密码，密码可以不用填直接<code>enter</code>键跳过也可以：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428231006771.png"alt="生成公钥" /><figcaption aria-hidden="true">生成公钥</figcaption></figure><p>注意标红处为公钥和私钥文件生成的文件夹地址。</p><h4 id="在gitee中添加公钥"><strong>2.4.2 在Gitee中添加公钥</strong></h4><p>以记事本格式打开pub公钥文件，将其中的公钥复制出来：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428231504015.png"alt="复制公钥" /><figcaption aria-hidden="true">复制公钥</figcaption></figure><p>在Gitee个人主页--&gt;个人设置--&gt;安全设置--&gt;SSH公钥处，将这段公钥粘贴进去,完成添加：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230428231723570.png"alt="添加公钥" /><figcaption aria-hidden="true">添加公钥</figcaption></figure><h4 id="使用git操作gitee5"><strong>2.4.3使用Git操作Gitee</strong><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="M870 RUSH RUSH，Git连接Gitee的环境配置及使用方法[EB/OL]，[https://blog.csdn.net/weixin_43736652/article/details/116028009](https://blog.csdn.net/weixin_43736652/article/details/116028009)，2021-04-22">[5]</span></a></sup></h4><p><strong>1)Pull项目【pull意为拉取】</strong>Gitee中打开某个想Pull的仓库，点击克隆/下载，随后在其下的选项中选择SSH，点击网址右侧的复制。回到本地在Git中输入如下指令</p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-iose2am18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-iose2am18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 复制过来的网址<br></code></pre></td></tr></table></div></figure><p><strong>2)上传项目</strong> 在想上传的文件夹根目录右键打开Git BashHere，输入指令，将文件存入暂存区(注意，add后有个’.’</p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-3g9ec2m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-3g9ec2m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></div></figure><p><strong>3)将文件存入本地git仓库</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-2nfvmcm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-2nfvmcm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m “消息”<br></code></pre></td></tr></table></div></figure><p><strong>4)查看状态</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wj0t3om18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-wj0t3om18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></div></figure><p><strong>5)上传至云端</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-it0w43m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-it0w43m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master<br></code></pre></td></tr></table></div></figure><div class="note note-info">            <p>到此即完成了一个简单静态页面的创建与更新，如果想要更复杂美观的页面，也可以通过上传自己编写的前端代码到仓库。较为复杂的博客页面也可以通过这种方式部署，而更新博客页面就可以通过更新仓库代码文件实现。显然，对于一个博客页面其核心是博客文章内容，此刻如何快捷地只更新博客内容是大家都关心的问题。最原始的方式就是在本地先慢慢修改好自己的代码文件，再使用原生的Git命令从本地远程更新Gitee代码仓库，这样做首先是博客代码方面，自己可能会懒得写博客页面的代码，大多数人只关心最核心的博客文章内容产出，不想去关心源码层面；其次是Git操作方面，各式各样的源码文件提交实在是太繁琐。所以，怎么办呢？肯定是用一些现成的、成熟的框架去搭建呗，让我们只用关心文章内容产出，源码什么的或者是怎么更新仓库代码等种种问题都别去操心了，此刻，Hexo他不就来了吗[狗头]✌️。</p>          </div><h2id="三进阶1使用优秀的博客模板hexo">三、进阶1：使用优秀的博客模板【Hexo】</h2><h3 id="什么是hexo">3.1 什么是Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <ahref="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Hexo官网，Hexo文档[EB/OL]，[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)">[6]</span></a></sup>。(<ahref="https://hexo.io/zh-cn/docs/">Hexo官方文档地址</a>)</p><h3 id="hexo的安装7">3.2Hexo的安装<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="codingpath，2022 Hexo 博客搭建和使用教程(Windows)[EB/OL]，[https://zhuanlan.zhihu.com/p/547520780](https://zhuanlan.zhihu.com/p/547520780)，2022-07-30">[7]</span></a></sup></h3><p>安装Hexo前需要安装Node.js，未安装<ahref="https://zhuanlan.zhihu.com/p/442215189">点此</a>查看教程。</p><h4 id="安装-cnpm"><strong>3.2.1 安装 cnpm</strong></h4><p>当您安装 Node.js 之后，便可以在命令行中通过 node install命令安装您想要的程序了。但本文推荐使用 cnpm 安装 Hexo，所以需要先通过npm install 安装 cnpm。</p><ul><li>命令:<code>npm install -g cnpm --registry==https://registry.npm.taobao.org</code>说明: -g 表示进行全局安装，--registry==<ahref="https://link.zhihu.com/?target=https%3A//registry.npm.taobao.org/">https://registry.npm.taobao.org</a>表示使用淘宝镜像安装 cnpm</li><li>安装后验证: 在 cmd 中输入命令 cnpm -v, 可查看 cnpm 版本</li></ul><figure><imgsrc="https://pic1.zhimg.com/80/v2-4a4d5d6ee394b06c85ed541f7eca9824_720w.webp"alt="查看cnpm版本" /><figcaption aria-hidden="true">查看cnpm版本</figcaption></figure><h4 id="安装-hexo"><strong>3.2.2 安装 Hexo</strong></h4><ul><li>命令: <code>cnpm install -g hexo-cli</code> 说明: -g表示全局安装，hexo-cli 为所安装的包</li><li>安装后验证: 在 cmd 中输入命令 hexo -v, 可查看 hexo 版本</li></ul><figure><imgsrc="https://pic2.zhimg.com/80/v2-482729ea2fce677d33e5ecfc78d67a79_720w.webp"alt="查看hexo版本" /><figcaption aria-hidden="true">查看hexo版本</figcaption></figure><h4 id="注意事项"><strong>3.2.3 注意事项</strong></h4><p>建议永远安装最新版本的 Hexo，以及 <ahref="https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/index.html%23%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的Node.js 版本</a>。</p><table><thead><tr class="header"><th>Hexo 版本</th><th>最低兼容 Node.js 版本</th></tr></thead><tbody><tr class="odd"><td>6.0+</td><td>12.13.0</td></tr><tr class="even"><td>5.0+</td><td>10.13.0</td></tr><tr class="odd"><td>4.1 - 4.2</td><td>8.10</td></tr><tr class="even"><td>4.0</td><td>8.6</td></tr><tr class="odd"><td>3.3 - 3.9</td><td>6.9</td></tr><tr class="even"><td>3.2 - 3.3</td><td>0.12</td></tr><tr class="odd"><td>3.0 - 3.1</td><td>0.10 or iojs</td></tr><tr class="even"><td>0.0.1 - 2.8</td><td>0.10</td></tr></tbody></table><h3 id="初始化一个hexo博客">3.3 初始化一个Hexo博客</h3><p>新建一个文件夹，例如blog，在blog文件夹右键<code>Gitee Bash Here</code>：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230429204506743.png"alt="打开Git" /><figcaption aria-hidden="true">打开Git</figcaption></figure><p>使用以下命令初始化一个Hexo博客，命名为test：</p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wl9r3vm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-wl9r3vm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init 文件夹名<br></code></pre></td></tr></table></div></figure><p>等待一会儿，如图生成了一个test文件夹：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230429204757190.png"alt="初始化生成文件夹" /><figcaption aria-hidden="true">初始化生成文件夹</figcaption></figure><figure><img src="../img/在Gitee上搭建个人博客/image-20230429204954065.png"alt="文件夹内部结构" /><figcaption aria-hidden="true">文件夹内部结构</figcaption></figure><p>进入test文件夹，打开Git窗口(即右键<code>Git bash here</code>)，输入命令<code>hexo g</code>后再输入命令<code>hexo server -port 端口号</code>，这里我使用的端口号是<code>5000</code> ：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230429210418959.png"alt="生成博客内容文件并开启Hexo本地服务器" /><figcaptionaria-hidden="true">生成博客内容文件并开启Hexo本地服务器</figcaption></figure><p>浏览器打开<code>http://localhost:5000/</code>，出现Hexo的HelloWorld页面即代表成功：</p><figure><img src="../img/在Gitee上搭建个人博客/image-20230429210614915.png"alt="Hexo主页" /><figcaption aria-hidden="true">Hexo主页</figcaption></figure><h3 id="hexo博客各初始文件说明">3.4 Hexo博客各初始文件说明</h3><p>见官方文档，我这懒得写了。</p><h3 id="hexo命令说明">3.5 Hexo命令说明</h3><p>这里指介绍几个重要的，其余可以见Hexo官方文档：</p><p><strong>①新建博客文章：</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-8jjkt6m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-8jjkt6m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></div></figure><p><code>[]</code>代表可选项，<code>layout</code>意为选中使用哪个模板，<code>title</code>为文章的题目，例如假如新建了一个diary模板，则<code>hexo new diary "我以diary为模板初始化"</code>意为以diary模板生成一个md博客文件，此时这个模板由于不是三个默认模板之一，生成的文件会放到<code>_post</code>文件夹下。不过大多数我们写文章的时候肯定是先打个草稿，不希望他直接就去<code>_post</code>文件夹里面发布了，所以可以先把文章放到草稿文件夹<code>_draft</code>里，写完了再把它放进<code>_post</code>文件夹里：</p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wph0p2m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-wph0p2m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;title&gt;<br></code></pre></td></tr></table></div></figure><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-03dpphm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-03dpphm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish draft &lt;title&gt;<br></code></pre></td></tr></table></div></figure><p><strong>②清除Hexo生成博客文件：</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-eg3qk8m18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-eg3qk8m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clear <br></code></pre></td></tr></table></div></figure><p>这个命令应该是为这种情况服务的：有时手动删除了多个博客源文件（即source文件夹下的文件），又手动新增了多个，这个时候如果使用<code>hexo generate</code>可能会报错，因为内容对不上了，所以此时可以手动删除所有发布用的博客文件，删除后重新生成就行了。</p><p><strong>③生成Hexo博客文件：</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-bdbprjm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-bdbprjm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></div></figure><p>借用<code>source</code>下的博客源文件在<code>public</code>下生成发布博客文件。</p><p><strong>④启动本地Hexo博客服务器：</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-8owz7gm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-8owz7gm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server --port=4000<br></code></pre></td></tr></table></div></figure><p>启动本地的Hexo服务器，可以在本地预览自己写的博客，默认端口就是4000。</p><p><strong>⑤发布Hexo博客文件到git仓库：</strong></p><figure class="highlight bash"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-2hy7zbm18zzwd7"></i><span>BASH</span><div class="collapse show" id="collapse-2hy7zbm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></div></figure><h2 id="四进阶2使用hexo主题fluid">四、进阶2：使用Hexo主题——Fluid</h2><div class="note note-warning">            <p>注意，本教程只介绍Fluid的基本配置，更多配置信息请前往<ahref="https://hexo.fluid-dev.com/">Fluid官网</a>查看用户配置手册</p>          </div><h3 id="fluid与hexo">4.1 Fluid与Hexo</h3><p>Fluid是基于Hexo的一款 Material Design风格的博客主题<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Fluid，Hexo Fluid用户手册[EB/OL]，[https://hexo.fluid-dev.com/docs/](https://hexo.fluid-dev.com/docs/)">[8]</span></a></sup>，相当于Android里的MIUI，又深度定制了一下，目前本博客就是用的Fluid主题。</p><h3 id="fluid的安装与更新">4.2 Fluid的安装与更新</h3><p><strong>①安装方式一：npm安装</strong></p><p>Hexo 5.0.0 版本以上，推荐通过 npm直接安装，进入博客目录执行命令：</p><figure class="highlight sh"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-cb8e6lm18zzwd7"></i><span>SH</span><div class="collapse show" id="collapse-cb8e6lm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></div></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的<code>_config.yml</code>内容复制过去。</p><p><strong>②安装方式二：直接解压安装</strong></p><p>下载 <ahref="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新release 版本</a>解压到 themes 目录，并将解压出的文件夹重命名为<code>fluid</code>。</p><p>文件安装完成后，如下修改 Hexo 博客目录中的<code>_config.yml</code>：</p><figure class="highlight yaml"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-szm0s7m18zzwd7"></i><span>YAML</span><div class="collapse show" id="collapse-szm0s7m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></div></figure><p><strong>③更新</strong>：同安装方式，npm就<code>npm update --save hexo-theme-fluid</code>，解压缩也一样的，不过如果自己修改了一些代码的话，那就需要自己手动解决了。</p><h3 id="fluid的配置">4.3 Fluid的配置</h3><p>全局页面：博客标题、顶部大图、网页统计</p><p>文章页：首页封面图、顶部大图、日期、评论</p><p>关于页：创建、关于信息</p><h2 id="五进阶3细节优化">五、进阶3：细节优化</h2><h3 id="博客的自动部署">5.1 博客的自动部署</h3><p>github action</p><h3 id="开通博客文章评论区">5.2 开通博客文章评论区</h3><p>valine+leancloud无后端评论系统</p><h3 id="设置博客访问量统计">5.3 设置博客访问量统计</h3><p>busuanzi</p><h2 id="六注意事项">六、注意事项</h2><h2 id="七常见问题">七、常见问题</h2><p>生成博客文章时，时间总是慢几个小时</p><h1 id="参考文献">参考文献</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>杨根杰，Git是什么？可以用来做什么？如何使用？[EB/OL]，<ahref="https://zhuanlan.zhihu.com/p/99313784">https://zhuanlan.zhihu.com/p/99313784</a>，2019-12-25<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>Gitee，Gitee帮助中心[EB/OL]，<ahref="https://gitee.com/help/articles/4105">https://gitee.com/help/articles/4105</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>有没有人告诉你，git、gitee、github、gitlab区别以及功能[EB/OL]，<ahref="https://blog.csdn.net/ios_xumin/article/details/118361335">https://blog.csdn.net/ios_xumin/article/details/118361335</a>，2021-06-30<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>码农充电站，如何使用Markdown编写文档[EB/OL]，<ahref="https://zhuanlan.zhihu.com/p/136440613">https://zhuanlan.zhihu.com/p/136440613</a>，2020-04-26<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>M870 RUSHRUSH，Git连接Gitee的环境配置及使用方法[EB/OL]，<ahref="https://blog.csdn.net/weixin_43736652/article/details/116028009">https://blog.csdn.net/weixin_43736652/article/details/116028009</a>，2021-04-22<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>Hexo官网，Hexo文档[EB/OL]，<ahref="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>codingpath，2022 Hexo博客搭建和使用教程(Windows)[EB/OL]，<ahref="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a>，2022-07-30<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>Fluid，HexoFluid用户手册[EB/OL]，<ahref="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a><a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>工具的安装、配置或使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>待完成</tag>
      
      <tag>免费</tag>
      
      <tag>博客搭建</tag>
      
      <tag>Gitee Pages</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitee，还是算了</title>
    <link href="/article/c63ea81.html"/>
    <url>/article/c63ea81.html</url>
    
    <content type="html"><![CDATA[<p>搞半天发现Gitee不能自定义域名，还得开Pro，一年99￥，有这钱我不去整个云服务器香？拜拜了</p><p>算了，github真特么卡，我又回来啦！</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Gitee你先人</tag>
      
      <tag>靠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客内容规范</title>
    <link href="/article/a23d648e.html"/>
    <url>/article/a23d648e.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h1 id="前言">前言</h1><p>最近发现用互联网存储数据是挺方便的，不论是存在自己本地电脑上还是实体纸质笔记本上，一是不方便，二是容易丢失，我自己电脑隔三差五格式化一下，真的风险高，所以决定转移到网络上。当然有想过自己建个站，租个大厂的云服务器，但是是真**的有点贵，遂放弃。思来想去，想起了Gitee，这玩意儿应该不会跑路吧？(注：目前已经确定GiteePages已经跑路，我真的笑了)</p><p>本着免费的不能浪费的原则，既然Gitee提供了这么一个免费的服务，不用白不用。之前是用的Github，但是时不时Github就被墙，导致每次更新文档或者加载文档都有可能就卡在那了，是真的难用，所以还是放弃了，之前写了几篇内容也荒废在那了，我也懒得管了。</p><p>本文章是我在Gitee Pages上的第一篇文章(注：在2024年5月份，GiteePages已经无法使用，本人现已经将所有文章转移至GithubPages)，本文章将主要为后续博客内容以及格式规范做一个明确的方向指导，本文会不断更新，直至博客格式最终固定下来(注：时至2024年8月20日17:56:00，我的博客格式还是乱七八糟的[笑])。</p><h1 id="正文">正文</h1><h2 id="一未来内容规划">一、未来内容规划</h2><p>预计未来会在博客上记录的东西：</p><ul class="task-list"><li><label><input type="checkbox"checked="" />编程实践上的经验记录</label></li><li><label><input type="checkbox"checked="" />理论学习上的知识总结</label></li><li><label><input type="checkbox"checked="" />计算机软硬件工具的经验记录</label></li><li><label><input type="checkbox" checked="" />个人杂想</label></li><li><label><input type="checkbox"checked="" />其他乱七八糟的东西</label></li></ul><h2 id="二文章要求说明">二、文章要求说明</h2><p>目前之所以需要一个规范来约束整篇文章呈现方式，实际上是为了方便整篇文章的阅读，当然还有方便写文章（因为不用每次再去组织文章结构了）。所以，合理使用该规范，例如过于简单的文章，那就随便写写就行了，没必要整太大阵仗。</p><h3 id="分类规范">2.1 分类规范</h3><p>对于所有文章必须有两个分类，一个是层级分类，一个是非层级分类。</p><h4 id="层级分类">2.1.1 层级分类</h4><p>层级分类是有层次结构并可用于快速手动索引查询的分类，可通过<ahref="/categories/">分类页</a>直接查询某文章，例如某一篇文章的层次分类为：学科-&gt;语文-&gt;散文这样的有层次结构的分类。归档分类必须遵循层次分明、意义明确的原则，同时原则上归档分类层次不得超过三级。详细的归档分类见附录：<ahref="#归档分类层次表">归档分类层次表</a>。</p><h4 id="非层级分类">2.1.2 非层级分类</h4><p>非层级分类是没有层次结构的分类，也可叫做标签分类（因为这里实际上是通过加标签的方式来分类文章的）。所有标签均平级，用于给某篇文章的内容关联上详细的属性标签，例如某一篇文章的标签分类为：SpringBoot启动失败、SpringBoot经验总结、常见错误这些的没有划分层次等级的分类。各标签必须描述尽量精确，不能过于笼统，同时一篇文章应该最多不超过五个标签，<strong>其中必须有一个标签为<code>原创</code>或者<code>转载</code></strong>，若文章还未完成，必须要有个<code>未完成</code>的标签，所实际上用于描述文章的标签不能超过四个。注：标签分类存在的意义实际上主要是用于扩展文章的元描述内容。</p><h3 id="结构组成">2.2 结构组成</h3><p>每篇文章主要由以下几个部分组成：</p><ul><li>封面与摘要：用于读者快速了解文章大致内容。</li><li>文章详情页横幅：可用于读者快速了解文章大致内容。</li><li>原创声明：用于标记文章是否原创。</li><li>完成度声明：因为我经常鸽，防止自己都不知道文章写完没，故加一个说明。</li><li>前言：用于解释文章诞生原因或者其他前置内容。</li><li>正文：文章主题内容。</li><li>附录：文章附属内容，该部分一般是那些篇幅太长不方便放到正文里的内容，例如源代码段。</li><li>参考资料：用于标注文章引用内容的源。</li></ul><h3 id="各结构内容规范">2.3 各结构内容规范</h3><h4 id="封面与摘要">2.3.1 封面与摘要</h4><p>每篇文章必须有摘要内容，但是由于空间有限，所以文章的封面可以使用默认封面，不过对于一些比较重要的文章，还是建议找个简洁易懂的封面。注意，对于封面的选取，为适应夜间模式，应当尽量选择背景镂空透明的图片，每张图片尺寸为：270x150PX。</p><h4 id="文章详情页横幅">2.3.2 文章详情页横幅</h4><p>文章详情页横幅实际上是主要用于美观，而且由于这张图很大，为了节省空间，所以一般都是用默认的就行。</p><h4 id="原创声明">2.3.3 原创声明</h4><p>每篇文章必须要有原创声明，这是用来激励自己的标签，鼓励自己多多原创，注意：若是非原创文章，需要在前言部分再次声明，并注明源地址或者其他引用指引。在每篇文章开头会使用<code>TAG</code>来强调说明，格式使用fluid的TAG：</p><p>原创使用则健康绿色：</p><div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><p>转载则使用淡屎黄色：</p><div class="note note-warning">            <p>转载或微调文章，原作者：[在此键入原作者]</p>          </div><h4 id="前言-1">2.3.4 前言</h4><p>每篇文章必须要有前言部分，这样做的目的主要是为了记录每一篇文章的写作目的或者其他重要的关键信息，方便指引读者阅读文章。</p><h4 id="正文-1">2.3.5 正文</h4><p>正文部分最多分3个层级标题，防止副标题太多影响阅读体验。</p><h4 id="附录">2.3.6 附录</h4><p>为防止后续修改麻烦，附录中的每一个内容不应当有序号索引，每一个附录内容只需有一个标题索引即可，正文中使用HTML内连接来索引附录。</p><h4 id="参考资料">2.3.7 参考资料</h4><p>本着方便阅读同时方便使用MD文档书写的原则，这里对于所有类型的文献、资料引用格式都是使用一种格式，如下：</p><div class="note note-info">            <p>作者、其他主要作者...,题名[文献类型标识]:引用页码,出版地:出版者,获取和访问路径,文献更新日期或者出版年</p>          </div><p>以上是主体结构，看情况来取舍某些内容，例如引用某篇网络博客，则不需要使用出版地、出版者等信息。对于文献类型标识，这里使用<ahref="https://lib.tsinghua.edu.cn/wj/GBT7714-2015.pdf">《信息与文献-参考文献著录规则》（GB/T7714—2015）</a>里面的规范，如下：</p><figure><img src="../img/在Gitee上的第一篇博客/image-20240820182230054.png"alt="文件类型和标识代码" /><figcaption aria-hidden="true">文件类型和标识代码</figcaption></figure><figure><img src="../img/在Gitee上的第一篇博客/image-20240820182305574.png"alt="电子资源载体和标识代码" /><figcaption aria-hidden="true">电子资源载体和标识代码</figcaption></figure><h2 id="三其他">三、其他</h2><p>因为写一篇博客也不容易，而且我也希望每篇博客尽量写得好一点，所以对于每一篇博客的内容，还是应当做到不是什么阿猫阿狗的东西都要写进博客里面的，如果实在要写，那就写。</p><h1 id="附录-1">附录</h1><h2 id="归档分类层次表">归档分类层次表</h2><table style="text-align:center;"><tr><th>一级分类</th><th>二级分类</th><th>说明</th></tr><tr><td rowspan="7">编程实践</td><td>java</td><td>java语言语法基础、高级特性、编程应用等相关文章</td></tr><tr><td>c语言</td><td>c语言语法基础、编程应用等相关文章</td></tr><tr><td>python</td><td>python语言语法基础、编程应用等相关文章</td></tr><tr><td>后端综合</td><td>后端综合类文章，涉及的知识例如SSM框架、SpringBoot等</td></tr><tr><td>前端综合</td><td>前端综合类文章，涉及的知识例如前端的各种脚手架、三大基础件等</td></tr><tr><td>自动化</td><td>利用各种编程语言、工具实现工作自动化的教程文章，涉及的知识例如自动打卡签到、资源爬取等</td></tr><tr><td>其他</td><td>懒得分类的文章</td></tr><tr><td rowspan="4">计算机理论</td><td>数据结构</td><td>无</td></tr><tr><td>操作系统</td><td>无</td></tr><tr><td>计算机组成原理</td><td>无</td></tr><tr><td>计算机网络</td><td>无</td></tr><tr><td rowspan="3">计算机杂项</td><td>工具的安装、配置或使用</td><td>就是一些入门的知识，比如JDK环境变量配置、IDEA使用技巧等</td></tr><tr><td>项目文档、源码的阅读</td><td>无</td></tr><tr><td>其他</td><td>无</td></tr><tr><td rowspan="3">语文</td><td>散文</td><td>无</td></tr><tr><td>古诗</td><td>无</td></tr><tr><td>小说</td><td>无</td></tr><tr><td rowspan="3">数学</td><td>高等数学</td><td>无</td></tr><tr><td>离散数学</td><td>无</td></tr><tr><td>线性代数</td><td>无</td></tr><tr><td rowspan="3">英语</td><td>写作</td><td>无</td></tr><tr><td>听力</td><td>无</td></tr><tr><td>口语</td><td>无</td></tr><tr><td rowspan="1">音乐</td><td>唱</td><td>蔡徐坤</td></tr><tr><td rowspan="4">杂想</td><td>人物关系</td><td>无</td></tr><tr><td>社会现象</td><td>无</td></tr><tr><td>反思家附体</td><td>无</td></tr><tr><td>其他</td><td>无</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>第一篇文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>006_C语言中scanf与分隔符(空格、回车、tab)</title>
    <link href="/article/9ce751d.html"/>
    <url>/article/9ce751d.html</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>转载或微调文章，源地址见文末参考资料</p>          </div><p>众所周知，C语言中的scanf函数的作用是从标准输入设备(通常是键盘)读取输入值，并存储到参数列表中指针所指向的内存单元。下面从几个方面说一下一些稍微细节的东西。下面的实验都在vc6.0中通过。</p><h3 id="一scanf的返回值">一、scanf的返回值</h3><p>scanf通常返回的是成功赋值(从标准输入设备赋值到参数列表所指定的内存区域)的数据项数，如果出错或是遇到“endof file”（注意，如果想从键盘输入EOF，在windows的DOS窗口用Ctrl+Z或F6；在UNIX系统上，用CTRL+D），则返回EOF，比如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-bwmwwsm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-bwmwwsm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br></code></pre></td></tr></table></div></figure><p>如果x和y都被成功读入，那么scanf的返回值就是2;如果只有x被成功读入，返回值为1; 如果x和y都未被成功读入，返回值为0;如果遇到错误或遇到end of file，返回值为EOF。</p><h3 id="二scanf的处理机制">二、scanf的处理机制</h3><p>scanf以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf需要读取一个数据项，返现缓冲区当前是空的，那么程序就会在scanf代码处阻塞，等待用户输入，scanf函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf函数返回，程序继续执行。</p><h3id="三scanf对不同类型输入的处理方式">三、scanf对不同类型输入的处理方式</h3><p>首先，要清楚一个概念：空白字符(whitespace)。一般，程序中所指的空白字符是指空格(space)，回车(enter)和指标符(table)。</p><h4 id="整数-d">1、整数 %d</h4><p>对于整型数据的输入，也就是说"%d"类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf("%d%d",&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。下面是例1：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-pdqsyxm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-pdqsyxm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">int</span> a,b; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d\n&quot;</span>,a,b); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></div></figure><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-94rcokm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-94rcokm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">Output: <br>Input the value of a and b:<span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:<span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:<span class="hljs-number">123</span> <br><span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b: <br><span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:   <span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b: <span class="hljs-number">123</span> <span class="hljs-number">456</span> <br>a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span> <br>Input the value of a and b:^Z <br>Press any key to <span class="hljs-keyword">continue</span>...<br></code></pre></td></tr></table></div></figure><h4 id="字符串-s">2、字符串 %s</h4><p>scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\0’。下面是一个例子，可以看出scanf这货的边界控制还是要小心。如下例2：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-yp7csrm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-yp7csrm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a[<span class="hljs-number">5</span>],b[<span class="hljs-number">5</span>]; <br>    <span class="hljs-type">int</span> i; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,a,b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%s,b=%s\n&quot;</span>,a,b); <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:(%c) &quot;</span>,a[i],a[i]); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:(%c) &quot;</span>,b[i],b[i]); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></div></figure><p>运行结果：</p><p><imgsrc="../img/006_C语言中scanf与分隔符-空格、回车、tab/clip_image001.png" /></p><h4 id="字符-c">3、字符 %c</h4><p>scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。下面是例3：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-82lpw8m18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-82lpw8m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a ,b ; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%c,b=%c\n&quot;</span>,a,b); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></div></figure><p>运行结果：</p><p><imgsrc="006_C语言中scanf与分隔符-空格、回车、tab/clip_image002.png" />可以看出，在对字符数据输入的时候，由于缓冲区中有回车空格等数据，会导致输入数据比较诡异，为了解决这个问题，有以下方法：</p><p><strong>(1) 清空缓冲区</strong></p><p>在微软系统中，有一个名为fflush(stdin)的函数，可以用来清空缓冲区，如下例4：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-u921ivm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-u921ivm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>    <span class="hljs-type">char</span> a ,b ; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>,&amp;a,&amp;b)!=EOF) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%c,b=%c\n&quot;</span>,a,b); <br>        fflush(<span class="hljs-built_in">stdin</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the value of a and b:&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></div></figure><p>运行结果：</p><p><imgsrc="../img/006_C语言中scanf与分隔符-空格、回车、tab/clip_image003.png" /></p><p><strong>(2)将缓冲区的数据读出来</strong></p><p>有的编译系统并没有定义stdin的fflush操作，这个时候，可以把缓冲区中的数据读出来，有如下几种可行的方法：</p><p>①getchar()</p><p>将例4中的 fflush(stdin); 语句换成：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-yyycgsm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-yyycgsm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>((c=getchar())!=<span class="hljs-string">&#x27;\n&#x27;</span>&amp;&amp;c!=EOF);<br></code></pre></td></tr></table></div></figure><p>运行效果和上面的相同。</p><p>②gets()</p><p>char* gets(char*buffer)从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。换行符不作为读取串的内容，读取的换行符被转换为null值，并由此来结束字符串。读入成功，返回与参数buffer相同的指针；读入过程中遇到EOF(End-of-File)或发生错误，返回NULL指针。所以在遇到返回值为NULL的情况，要用ferror或feof函数检查是发生错误还是遇到EOF。要注意的是gets函数可以无限读取，不会判断上限，所以应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。如果溢出，多出来的字符将被写入到堆栈中，这就覆盖了堆栈原先的内容，破坏一个或多个不相关变量的值。</p><p>将例4中的 fflush(stdin); 语句换成：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-b3gqdvm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-b3gqdvm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> c[<span class="hljs-number">10</span>];<br>gets(c);<br></code></pre></td></tr></table></div></figure><p>运行效果也和上面的相同。</p><h4id="在stackoverflow上看到的一个问题">4、在stackoverflow上看到的一个问题</h4><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-plncllm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-plncllm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> a[<span class="hljs-number">4</span>]; <br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%s\n&quot;</span>, a); <br>    <span class="hljs-keyword">return</span> a; <br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">char</span> *h = method1(); <br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%s\n&quot;</span>, h); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></div></figure><p>运行结果：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-1gh63hm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-1gh63hm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">ab <br>cd <br>ab <br>Press any key to <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></div></figure><p>可以发现，输如两次之后才会输出。这个现象比较诡异，原因如下：</p><p>White space (such as blanks, tabs, or newlines) in the format stringmatch any amount of white space, including none, in the input.Everything else matches only itself.</p><p>Thus with scanf ("%s", a) it will scan for a string followed byoptional white space. Since after the first newline more whitespace mayfollow, scanf is not done after the first newline and looks what's next.You will notice that you can enter any number of newlines (or tabs orspaces) and scanf will still wait for more.</p><p>However, when you enter the second string, the sequence of whitespaceis delimited and scanning stops.</p><h6 id="参考资料">参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.csdndoc.com/article/4341194<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>C</tag>
      
      <tag>编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>005_不理解缓冲区导致数据输出异常</title>
    <link href="/article/95987ce.html"/>
    <url>/article/95987ce.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>转载或微调文章，源地址见文末参考资料</p>          </div><h2 id="一前言">一、前言</h2><p>作为一个以C语言作为编程启蒙的初学者，在学习C语言时也是遇到了许多问题，例如接下来要说到的”<strong>缓冲区理解问题</strong>“，有的时候如果<strong>把gets函数和scanf函数连用</strong>总会发生奇葩的错误，而如果不理解缓冲区这个概念的话，是很难明白为什么会发生这样或那样的错误的。在解决问题的过程中，搜索到了一篇写得很好的文章，在这里记录一下。</p><h2 id="二正文">二、正文</h2><h3 id="引入">1.引入</h3><p>从一个简单的例子开始：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-m03hu6m18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-m03hu6m18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>] ;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>] ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入文件名:&quot;</span>) ;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span> , a ) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入关键字:&quot;</span>) ;<br>    <span class="hljs-comment">//getchar() ;//fflush(stdin);</span><br>    gets(str) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span> , str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></div></figure><figure><img src="../img/005-不理解缓冲区导致数据输出异常/clip_image001.jpg"alt="输入jj后回车程序就结束了" /><figcaption aria-hidden="true">输入jj后回车程序就结束了</figcaption></figure><p>可以看到没等第二次的关键字的输入程序就运行结束了，这是为什么呢？要充分理解这个问题我们需要理解C语言中对缓冲区的概念。</p><p>在这之前我们初步分析一下，scanf函数输入字符串的的情况下空白字符（空格，回车，Tab）都只是被视为分隔符，关于这一点可以参考<ahref="/2022/03/31/006_C语言中scanf与分隔符-空格、回车、tab/">C语言中scanf与分隔符（空格回车Tab)</a>这篇博文，当我们输入字符串jj后按回车的时候就会把jj连同换行符送入缓冲区，然而scanf只会接收字符串jj，并把这个字符串送入到以a为首地址的地址空间中，同时在字符串后面自动加上一个\0，那么如今缓冲区内就只有一个换行符了。当执行到gets()函数的时候，因为缓冲区内非空，那么gets直接会读取缓冲区中的换行符复制到str为首地址的内存空间，同时在字符串后面自动加上一个\0，所以输出的str的结果就是一个换行罢了。</p><p>当我们取消程序中注释语句getchar()的时候，getchar()会接收缓冲区中的而第一个字符，那么缓冲区便空了。当执行到gets()的时候，由于缓冲区为空，那么程序便会停在gets()位置处的等待输入。然后我们输入字符串并且按回车将字符串送入缓冲区后，因为gets()的功能是获取缓冲区中的字符串，遇到换行符或者EOF后停止，所以gets()取出缓冲区内所有的字符串以及换行符，所以输出的结果如下图示：</p><p><img src="../img/005-不理解缓冲区导致数据输出异常/clip_image002.jpg"alt="使用getchar()读取缓冲区剩余内容" />可以看到连同换行符也一起输出来了。</p><p>当然除了使用getchar()来消除换行符的影响，也可以使用fflush(stdin)来刷新缓冲区，同样可以起到消除换行符的效果。因为fflush(stdin)的作用是清除标准输入缓冲区中的内容。</p><h3 id="缓冲区介绍">2.缓冲区介绍</h3><p>有了一些感性的认识，我们来看看缓冲区的概念和它的机制。</p><h4 id="什么是缓冲区">（1）什么是缓冲区</h4><p>缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。</p><p>缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。</p><h4 id="为什么要引入缓冲区">（2）为什么要引入缓冲区</h4><p>我们为什么要引入缓冲区呢？</p><p>比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。</p><p>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。</p><p>现在您基本明白了吧，缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。</p><h4 id="缓冲区的类型">（3）缓冲区的类型</h4><p>缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。</p><p><strong>①全缓冲：</strong>在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。</p><p><strong>②行缓冲：</strong>在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。</p><p><strong>③不带缓冲：</strong>也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。</p><h4 id="缓冲区的刷新">（4）缓冲区的刷新</h4><p>下列情况会引发缓冲区的刷新:</p><ul><li>缓冲区满时;</li><li>执行flush语句;</li><li>执行endl语句;</li><li>关闭文件。</li></ul><p>可见，缓冲区满或关闭文件时都会刷新缓冲区，进行真正的I/O操作。另外，在C++中，我们可以使用flush函数来刷新缓冲区(执行I/O操作并清空缓冲区)键盘操作演示行缓冲。</p><p>先介绍getchar()函数：</p><p>函数原型：int getchar(void);</p><p>说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。</p><p>不知道您明白了没有，再通俗一点讲，当程序调用getchar()函数时，程序就等着用户按键，并等用户按下回车键返回。期间按下的字符存放在缓冲区，第一个字符作为函数返回值。继续调用getchar()函数，将不再等用户按键，而是返回您刚才输入的第2个字符;继续调用，返回第3个字符，直到缓冲区中的字符读完后，才等待用户按键。</p><p>getchar()函数的执行就是采用了行缓冲。第一次调用getchar()函数，会让程序使用者(用户)输入一行字符并直至按下回车键函数才返回。此时用户输入的字符和回车符都存放在行缓冲区。再次调用getchar()函数，会逐步输出行缓冲区的内容。</p><p>运行一段代码体会一下：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-vdspamm18zzwd7"></i><span>C</span><div class="collapse show" id="collapse-vdspamm18zzwd7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> c ;<br>    c = getchar() ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span> , c ) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>运行结果：</p><figure><img src="../img/005-不理解缓冲区导致数据输出异常/clip_image004.jpg"alt="s后面的输入由于缓冲区已满而被无视" /><figcaptionaria-hidden="true">s后面的输入由于缓冲区已满而被无视</figcaption></figure><p>不断输入数据，当不能再输入数据的时候说明缓冲区已满，输入的字符的数目为4096，即4k。那么就可以知道缓冲区的大小为4k。</p><h6 id="参考资料">参考资料:</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.csdndoc.com/article/4341477<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>编程实践</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>C</tag>
      
      <tag>编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>004_vc6.0出现_oax1错误</title>
    <link href="/article/17c800ec.html"/>
    <url>/article/17c800ec.html</url>
    
    <content type="html"><![CDATA[<p>一般情况下是代码中夹杂了中文字符。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>原创</tag>
      
      <tag>编译报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>003_vc6.0添加插件时error解决方案</title>
    <link href="/article/3cc86140.html"/>
    <url>/article/3cc86140.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>博主原创文章，转载请说明出处，但是不说我也管不了你🏳️</p>          </div><h3id="unable-to-register-this-add-in-because-its-dllregisterserver-returns-an-error-解决方案">Unableto register this add-in because its DllRegisterServer returns an error解决方案</h3><p>详细步骤：</p><p><strong>1、</strong>以管理员身份重新启动VC6.0</p><p><strong>2、</strong>windows下使用administrator(管理员)身份登录，在"开始"菜单的搜索框中输入cmd回车，就可以看到该控制台程序了，然后右键单击，选择"以管理员身份运行"，此时就获得了管理员权限。或者进C:找到 cmd.exe 右键--管理员身份运行</p><p><strong>3、</strong>在弹出的命令窗口中使用注册命令</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wea7tam18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-wea7tam18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">regsvr32.exe <span class="hljs-string">&quot;add-in.dll&quot;</span><br></code></pre></td></tr></table></div></figure><p>例如：如果安装目录在c盘，只输入引号内的命令，进入c盘目录下然后输入命令：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-gb0ulmm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-gb0ulmm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">c:\&gt;regsvr32.exe <span class="hljs-string">&quot;c:\VC6CN\COMMON\MSDEV98\ADDINS\FileTool.dll&quot;</span><br></code></pre></td></tr></table></div></figure><p>成功后，此时VC界面中会出现一个上面只有两个图标的工具栏，可以将其拖放到自己认为合适的位置，然后关闭VC6.0并重新启动程序</p><h6 id="参考资料">参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>www.docin.com<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>注：由于该笔记历史久远，是当时学习C语言时使用VC6.0遇到的问题，由于没把笔记写好，我自己也看不懂了，故本经验参考性不大<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>VC6.0</tag>
      
      <tag>IDE环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>002_void及void指针含义的深刻解析</title>
    <link href="/article/c3cc1022.html"/>
    <url>/article/c3cc1022.html</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>未知来源转载文章</p>          </div><h2 id="简化版概述">简化版概述</h2><h3 id="一void-的含义">一、void 的含义</h3><p>void 即“无类型”，void *则为“无类型指针”，可以指向任何数据类型。</p><h3 id="二void-指针使用规范">二、void 指针使用规范</h3><p><strong>①void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对 void指针赋值。</strong></p><p>例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-zgbrbxm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-zgbrbxm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pint;<br><span class="hljs-type">void</span> *pvoid; <br>pvoid = pint;  <span class="hljs-comment">//不过不能 pint = pvoid;</span><br></code></pre></td></tr></table></div></figure><p>如果要将 pvoid 赋给其他类型指针，则需要强制类型转换如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-5mqhb2m18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-5mqhb2m18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">pint = (<span class="hljs-type">int</span> *)pvoid;<br></code></pre></td></tr></table></div></figure><p>**②在 ANSI C 标准中，不允许对 void 指针进行算术运算如 pvoid++或pvoid+=1 等，而在 GNU 中则允许，因为在缺省情况下，GNU 认为 void <em>与char </em>一样。 sizeof( *pvoid )== sizeof( char )。**</p><h3 id="三void-的作用">三、void 的作用</h3><p><strong>①对函数返回的限定。</strong></p><p><strong>②对函数参数的限定。</strong></p><p>当函数不需要返回值时，必须使用 void 限定。例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-bzg3cxm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-bzg3cxm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></div></figure><p>当函数不允许接受参数时，必须使用 void 限定。例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-8a2yrrm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-8a2yrrm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></div></figure><p>由于 void 指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void 指针赋值，因此还可以用 void指针来作为函数形参，这样函数就可以接受任意数据类型的指针作为参数。例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-no44bdm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-no44bdm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * <span class="hljs-title function_">memcpy</span><span class="hljs-params">( <span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len )</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">memset</span><span class="hljs-params">( <span class="hljs-type">void</span> * buffer, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> num )</span>;<br></code></pre></td></tr></table></div></figure><h2 id="详细版说明">详细版说明</h2><p>许多初学者对 C/C++语言中的 void 及 void指针类型不甚理解，因此在使用上出现了一些错误。本文将对 void关键字的深刻含义进行解说，并详述 void 及 void指针类型的使用方法与技巧。</p><h3 id="一void-的含义-1">一、void 的含义</h3><p>void 的字面意思是“无类型”，void <em>则为“无类型指针”，void</em>可以指向任何类型的数据。void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个 void变量，让我们试着来定义：</p><figure class="highlight abnf"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-folywkm18zzwd6"></i><span>ABNF</span><div class="collapse show" id="collapse-folywkm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></div></figure><p>这行语句编译时会出错，提示“illegal use of type ’void’”。不过，即使void a 的编译不会出错，它也没有任何实际意义。 void真正发挥的作用在于：</p><p>（1）对函数返回的限定；</p><p>（2） 对函数参数的限定。</p><p>众所周知，如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2间互相赋值；如果 p1 和 p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-y701fim18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-y701fim18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p1 = p2;<br></code></pre></td></tr></table></div></figure><p>其中 p1 = p2 语句会编译出错，提示 “ ’=’ : cannot convert from ’int<em>’ to ’ float </em>’ ”，必须改为： p1 = (float *)p2;</p><p>而 void*则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-3wsahvm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-3wsahvm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p1 = p2; <br></code></pre></td></tr></table></div></figure><p>但这并不意味着，void*也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。</p><p>下面的语句编译出错：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-9fb0i9m18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-9fb0i9m18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *p1; <br><span class="hljs-type">int</span> *p2;<br>p2 = p1; <br></code></pre></td></tr></table></div></figure><p>提示 “ ’=’ : cannot convert from ’void <em>’ to ’int </em>’ ”。</p><h3 id="二void-的使用">二、void 的使用</h3><p>下面给出 void 关键字的使用规则：</p><h5 id="规则一-如果函数没有返回值那么应声明为-void-类型">规则一：如果函数没有返回值，那么应声明为 void 类型。</h5><p>在 C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为void 类型。例如：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-bv18f1m18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-bv18f1m18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">add ( <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b ) <br>&#123;<br>    <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> <br>&#123; <br>    <span class="hljs-built_in">printf</span> ( \<span class="hljs-string">&quot;2 + 3 = %d\&quot;, add ( 2, 3) ); </span><br><span class="hljs-string">&#125; </span><br></code></pre></td></tr></table></div></figure><p>程序运行的结果为输出：</p><figure class="highlight basic"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-gn9sukm18zzwd6"></i><span>BASIC</span><div class="collapse show" id="collapse-gn9sukm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>+ <span class="hljs-number">3</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></div></figure><p>这说明不加返回值说明的函数的确为 int 函数。</p><p>林锐博士《高质量C/C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在Visual C++6.0 中上述 add函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。</p><p>因此，为了避免混乱，我们在编写C/C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void 类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。</p><h5id="规则二如果函数无参数那么应声明其参数为-void">规则二：如果函数无参数，那么应声明其参数为void 。</h5><p>在 C++语言中声明一个这样的函数：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-9xxmvqm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-9xxmvqm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125; <br></code></pre></td></tr></table></div></figure><p>则进行下面的调用是不合法的：</p><figure class="highlight actionscript"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-t30213m18zzwd6"></i><span>ACTIONSCRIPT</span><div class="collapse show" id="collapse-t30213m18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span><span class="hljs-params">(2)</span>;<br></code></pre></td></tr></table></div></figure><p>因为在 C++中，函数参数为 void 的意思是这个函数不接受任何参数。</p><p>我们在 Turbo C 2.0 中编译：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-13x89om18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-13x89om18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> \<span class="hljs-string">&quot;stdio.h\&quot; </span></span><br><span class="hljs-string"><span class="hljs-meta">fun() </span></span><br><span class="hljs-string"><span class="hljs-meta">&#123; </span></span><br><span class="hljs-string"><span class="hljs-meta">    return 1; </span></span><br><span class="hljs-string"><span class="hljs-meta">&#125; </span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">main() </span></span><br><span class="hljs-string"><span class="hljs-meta">&#123; </span></span><br><span class="hljs-string"><span class="hljs-meta">    printf(\&quot;%d\&quot;,fun(2)); getchar(); </span></span><br><span class="hljs-string"><span class="hljs-meta">&#125; </span></span><br></code></pre></td></tr></table></div></figure><p>编译正确且输出 1，这说明，在 C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示 “ ’fun’ : function doesnot take 1 parameters”。所以，无论在 C 还是C++中，若函数不接受任何参数，一定要指明参数为 void。</p><h5 id="规则三小心使用-void-指针类型">规则三：小心使用 void指针类型</h5><p>按照 ANSI(American National Standards Institute)标准，不能对 void指针进行算法操作，即下列操作都是不合法的：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-eqff9om18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-eqff9om18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * pvoid; <br>pvoid++; <span class="hljs-comment">//ANSI：错误 </span><br>pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//ANSI：错误 </span><br><br><span class="hljs-comment">//ANSI 标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。 </span><br><span class="hljs-comment">//例如： </span><br><span class="hljs-type">int</span> *pint; <br>pint++; <span class="hljs-comment">//ANSI：正确，pint++的结果是使其增大 sizeof(int)。 </span><br></code></pre></td></tr></table></div></figure><p>但是大名鼎鼎的 GNU(GNU’s Not Unix 的缩写)则不这么认定，它指定 void<em>的算法操作与 char </em>一致。 因此下列语句在 GNU编译器中皆正确：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-wct8cgm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-wct8cgm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">pvoid++; <span class="hljs-comment">//GNU：正确 </span><br><br>pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//GNU：正确 pvoid++的执行结果是其增大了 1</span><br></code></pre></td></tr></table></div></figure><p>在实际的程序设计中，为迎合 ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-fhpasam18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-fhpasam18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * pvoid; <br>(<span class="hljs-type">char</span> *)pvoid++; <span class="hljs-comment">//ANSI：正确；GNU：正确 </span><br>(<span class="hljs-type">char</span> *)pvoid += <span class="hljs-number">1</span>; <span class="hljs-comment">//ANSI：错误；GNU：正确 </span><br></code></pre></td></tr></table></div></figure><p>GNU 和 ANSI 还有一些区别，总体而言，GNU 较 ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI 标准。</p><h5id="规则四如果函数的参数可以是任意类型指针那么应声明其参数为-void">规则四：如果函数的参数可以是任意类型指针，那么应声明其参数为void *。</h5><p>典型的如内存操作函数 memcpy 和 memset 的函数原型分别为：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-nl7i5dm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-nl7i5dm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> * <span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span>;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">memset</span><span class="hljs-params">( <span class="hljs-type">void</span> * buffer, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> num )</span>;<br></code></pre></td></tr></table></div></figure><p>这样，任何类型的指针都可以传入 memcpy 和 memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy 和 memset 的参数类型不是 void <em>，而是 char</em>，那才叫真的奇怪了！这样的 memcpy 和 memset明显不是一个“纯粹的，脱离低级趣味的” 函数！下面的代码执行正确：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-rrvo5um18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-rrvo5um18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//示例：memset 接受任意类型指针 </span><br><span class="hljs-type">int</span> intarray[<span class="hljs-number">100</span>]; [Page] <br><span class="hljs-built_in">memset</span> ( intarray, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) ); <span class="hljs-comment">//将 intarray 清 0 </span><br><br><span class="hljs-comment">//示例：memcpy 接受任意类型指针 </span><br><span class="hljs-type">int</span> intarray1[<span class="hljs-number">100</span>],intarray2[<span class="hljs-number">100</span>]; <br><span class="hljs-built_in">memcpy</span>(intarray1,intarray2,<span class="hljs-number">100</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//将 intarray2 拷贝给 intarray1</span><br></code></pre></td></tr></table></div></figure><p>有趣的是，memcpy 和 memset 函数返回的也是 void*类型，标准库函数的编写者是多么地富有学问啊！</p><h5 id="规则五void-不能代表一个真实的变量">规则五：void不能代表一个真实的变量</h5><p>下面代码都企图让 void 代表一个真实的变量，因此都是错误的代码：</p><figure class="highlight c"><i class="iconfont icon-code" type="button" data-toggle="collapse" data-target="#collapse-8oghlqm18zzwd6"></i><span>C</span><div class="collapse show" id="collapse-8oghlqm18zzwd6"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> a; <span class="hljs-comment">//错误</span><br>function(<span class="hljs-type">void</span> a); <span class="hljs-comment">//错误 </span><br></code></pre></td></tr></table></div></figure><p>void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人（还有人妖？）。void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称 void 为“抽象数据类型”）变量。</p><h3 id="三总结">三、总结</h3><p>小小的 void蕴藏着很丰富的设计哲学，作为一名程序设计人员，对问题进行深一个层次的思考必然使我们受益匪浅。</p><hr /><h6 id="参考资料">参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度上搜的，到底哪来的忘了<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未知来源转载</tag>
      
      <tag>C</tag>
      
      <tag>编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001_键盘两种输入模式是什么意思</title>
    <link href="/article/cbedf9fe.html"/>
    <url>/article/cbedf9fe.html</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>转载或微调文章，源地址见文末参考资料</p>          </div><p>键盘上能用于切换“插入”与“覆盖（改写）”两种状态的双态键是INSERT键。Insert音标[inˈsə:t] 发音为"因色特"。</p><p><a href="百度图片"><imgsrc="https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/7e3e6709c93d70cfb306aeb4fedcd100bba12b8e.jpg"alt="IMG_256" /></a></p><p>插入键（Insert key，缩写INS）是<ahref="https://www.baidu.com/s?wd=电脑键盘&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">电脑键盘</a>的一个键，主要用于在文字处理器切换文本输入的模式。一种为覆盖模式，光标位置新输入字会替代原来的字；另一种为插入模式，新输入的字插入到光标位置，原来的字相应后移。在早期的计算机终端里，如果在覆盖模式，光标会变成一个方块而不是通常的竖线。</p><p>鼠标点击可输入框后会出现闪动的光标。 一般情况下，<ahref="https://www.baidu.com/s?wd=Windows系统&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">Windows系统</a>默认光标位置插入字符，而光标向后移动，即输入时对光标后字符无影响。但是Insert是嵌入，即插入并覆盖，所以当按下Insert键后再输入，光标后的字符会被消去，即被当前输入字符替换掉，再次按下后则会还原到默认插入状态。</p><hr /><h6 id="参考资料">参考资料：</h6><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>百度百科<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机杂项</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Windows常识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/article/77770c79.html"/>
    <url>/article/77770c79.html</url>
    
    <content type="html"><![CDATA[<h2 id="花了半下午">花了半下午！</h2><p>虽然都是用别人现成的东西搭建的博客，但是还是遇到了好多问题，现在终于弄完了，哈哈纪念一下！</p><p><img src="../img/HelloWorld/fw.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
